# -*- coding: utf-8 -*-
"""
/***************************************************************************
 qcrocoflowDockWidget
                                 A QGIS plugin
 A QGIS plugin to manage CROCO projectsqcrocoflow
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-12-03
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Emmanuel Poizot
        email                : emmanuel.poizot@lecnam.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from pathlib import Path

from qgis.gui import (
    QgsMapToolEmitPoint,
    QgsMessageBar)
from qgis.core import (
    QgsCoordinateReferenceSystem,
    QgsRasterLayer,
    QgsProject,
    QgsMessageLog,
    Qgis)

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, Qt, QEvent, QRect
from qgis.PyQt.QtWidgets import (
    QDialog,
    QMessageBox,
    QFileDialog,
    QVBoxLayout, QHBoxLayout, QGridLayout,
    QComboBox,
    QMenuBar,
    QAction,
    QMainWindow,
    QApplication,
    QTextEdit,
    QToolBar,
    QLabel,
    QDockWidget,
    QWidget,
    QLineEdit,
    QPushButton)
from PyQt5.QtWidgets import QInputDialog


import netCDF4 as nc
import datetime

from .qcrocoflow_croco2qgis import qcrocoflowCROCO2QGIS
from .qcrocoflow_qcrocotools import netCDFtoRaster
from .qcrocoflow_config import *
from .Preprocess.qcrocoflow_crocogrid_dialog import *

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'qcrocoflow_dockwidget_base.ui'))

class qcrocoflowDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, _iface, parent=None):
        """Constructor."""
        super(qcrocoflowDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect

        # Get pointer on QGIS interface
        self.iface  = _iface
        self.grdDlg = None
        # Construction of menu bar entries and relative actions
        self.myQMenuBar = QMenuBar(self)

        ### Project ################################
        self.projectMenu = self.myQMenuBar.addMenu('Project')
        self.newProjectAction = QAction('New...', self)
        self.newProjectAction.triggered.connect(self.NewProject)
        self.projectMenu.addAction(self.newProjectAction)
        # ---
        self.openProjectAction = QAction('Open...', self)
        self.openProjectAction.triggered.connect(self.OpenProject)
        self.projectMenu.addAction(self.openProjectAction)
        # ---
        self.saveProjectAction = QAction('Save', self)
        self.saveProjectAction.setEnabled(False)
        self.saveProjectAction.triggered.connect(self.SaveProject)
        self.projectMenu.addAction(self.saveProjectAction)
        # ---
        self.saveAsProjectAction = QAction('Save as...', self)
        self.saveAsProjectAction.setEnabled(False)
        self.saveAsProjectAction.triggered.connect(self.SaveAsProject)
        self.projectMenu.addAction(self.saveAsProjectAction)
        # ---
        self.projectMenu.addSeparator()
        # ---
        self.globalSettingsMenu = self.projectMenu.addMenu('Settings')
        self.workingDirectoryAction = QAction(' Set working directory...', self)
        self.workingDirectoryAction.triggered.connect(self.WorkingDirectory)
        self.globalSettingsMenu.addAction(self.workingDirectoryAction)
        # ---
        self.projectMenu.addSeparator()
        # ---
        self.closeProjectAction = QAction('Close', self)
        self.closeProjectAction.triggered.connect(self.CloseProject)
        self.projectMenu.addAction(self.closeProjectAction)
        ### Grid ################################
        self.gridMenu = self.myQMenuBar.addMenu('Grid')
        self.newGridAction = QAction('New...', self)
        self.newGridAction.triggered.connect(self.NewGrid)
        self.gridMenu.addAction(self.newGridAction)
        # ---
        self.openGridAction = QAction('Open...', self)
        self.openGridAction.triggered.connect(self.OpenGrid)
        self.gridMenu.addAction(self.openGridAction)
        # ---
        self.importGridAction = QAction('Import NetCDF...', self)
        self.importGridAction.triggered.connect(self.ImportNetCDFGrid)
        self.gridMenu.addAction(self.importGridAction)
        # ---
        self.gridMenu.addSeparator()
        # ---
        self.setConditionMenu= self.gridMenu.addMenu('Set conditions')
        self.initialConditionAction = QAction('Initial...', self)
        self.initialConditionAction.triggered.connect(self.printHello)
        self.setConditionMenu.addAction(self.initialConditionAction)
        # ---
        self.openBoundaryConditionAction = QAction('Boundary...', self)
        self.openBoundaryConditionAction.triggered.connect(self.printHello)
        self.setConditionMenu.addAction(self.openBoundaryConditionAction)
        ### Sediment ################################
        self.sedimentMenu = self.myQMenuBar.addMenu('Sediment')
        self.newSedimentAction = QAction('New...', self)
        self.newSedimentAction.triggered.connect(self.NewSediment)
        self.sedimentMenu.addAction(self.newSedimentAction)
        # ---
        self.openSedimentAction = QAction('Open...', self)
        self.openSedimentAction.triggered.connect(self.OpenSediment)
        self.sedimentMenu.addAction(self.openSedimentAction)
        # ---
        ### Tools ################################
        self.toolsMenu = self.myQMenuBar.addMenu('Tools')
        self.picCellAction = QAction('Get I,J...', self)
        self.picCellAction.triggered.connect(self.GetCellIJ)
        self.toolsMenu.addAction(self.picCellAction)
        # ---
        self.openSedimentAction = QAction('Open...', self)
        self.openSedimentAction.triggered.connect(self.OpenSediment)
        self.toolsMenu.addAction(self.openSedimentAction)
        # ---
        self.gridMenu.addSeparator()
        # ---
        ### Mars ################################
        self.marsMenu = self.myQMenuBar.addMenu('Mars')
        self.importMarsAction = QAction('Import...', self)
        self.importMarsAction.triggered.connect(self.ImportMarsResults)
        self.marsMenu.addAction(self.importMarsAction)

        # TODO: define other menu entries from here

        self.setupUi(self)

        # Variables
        self.SetToDefaultVariableValue('PROJECT')

        # Variables for mouse tracking events
        canvas = self.iface.mapCanvas()
        self.pointTool = QgsMapToolEmitPoint(canvas)
        self.pointTool.canvasClicked.connect(self.display_point)

    def SetToDefaultVariableValue(self, _type):
        if _type == 'PROJECT':
            self.projectOpened = False
            self.projectName = None
            self.xmlProject = None
            self.projectDirectory = os.path.expanduser("~user") # Default value for project directory
            self.currentWorkingDirectory = os.path.expanduser("~user")

    def display_point(self, pnt):
        QMessageBox.information(self.iface.mainWindow(), "Coordinate tracking", "x: {:.6f} - y: {:.6f}".format(pnt[0], pnt[1]))
        canvas = self.iface.mapCanvas()
        canvas.unsetMapTool(self.pointTool)

    def printHello(self) -> None:
        print('Hello')

    def NewProject(self) -> None:
    # Create a new empty QCrocoFlow project
        if self.projectOpened and self.projectName:
            QMessageBox.warning(self, "Project file", f"The QCrocoFlow project {self.projectName} is currently opened.\nClose it before create a new one")
            return
        dialog = QFileDialog(self)
        dialog.setOptions(QFileDialog.DontUseNativeDialog)
        dialog.setFileMode(QFileDialog.DirectoryOnly)
        dialog.setOption(QFileDialog.ShowDirsOnly)
        dialog.setWindowTitle("Select an existing CROCO directory")
        # dialog.setViewMode(QFileDialog.List)
        if (dialog.exec()):
            selectedDir = dialog.directory()  # Get the first element of the returned list
            xmlFileName = os.path.basename(selectedDir.absolutePath())+'.xml'
            selectedFullPathFileName = os.path.join(selectedDir.absolutePath(), 'QGIS', xmlFileName)
            if os.path.isfile(selectedFullPathFileName):
                ans = QMessageBox.information(self, "Project file exist", f"Do you want to overwrite {selectedFullPathFileName} ?", \
                            buttons=QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.Cancel, \
                             defaultButton = QMessageBox.StandardButton.Cancel)
                if ans == QMessageBox.StandardButton.Cancel:
                    return
            QMessageBox.information(self, "Project", f"{selectedFullPathFileName}")
            self.projectName = xmlFileName.split('.')[0]
            self.projectDirectory = selectedDir
            # TODO: manage creation of empty project file here
            self.xmlProject = qcrocoflow_XML_Management(self)
            self.xmlProject.InitializeRoot(selectedFullPathFileName)

            self.projectOpened = True
            self.saveProjectAction.setEnabled(True)
            self.saveAsProjectAction.setEnabled(True)
        else:
            QMessageBox.information(self, "Project file", "No QCrocoFlow project file created")
        return

    def OpenProject(self) -> None:
    # Open an existing QCrocoFlow  project
        if self.projectOpened and self.projectName:
            QMessageBox.warning(self, "Project file", f"The QCrocoFlow project {self.projectName} is currently opened.\nClose it before open a new one")
            return
        dialog = QFileDialog(self)
        dialog.setFileMode(QFileDialog.ExistingFile)
        dialog.setNameFilter("QCF project (*.xml *.XML)")
        dialog.setWindowTitle("Open QCrocoFlow existing project file")
        dialog.setViewMode(QFileDialog.Detail)
        if (dialog.exec()):
            selectedFileName = dialog.selectedFiles()[0] # Get the first element of the returned list
            self.projectName = os.path.basename(selectedFileName)
            self.projectDirectory = os.path.dirname(selectedFileName)
            self.projectOpened = True
            # TODO: manage import of project file here
            self.xmlProject = qcrocoflow_XML_Management(self)
            self.xmlProject.GetProjectSettings(selectedFileName)
            self.messagelogTextEdit.append(self.xmlProject.PrintCurrentSettings())
        else:
            QMessageBox.information(self, "Project file", "No QCrocoFlow project file selected")
        return

    def SaveProject(self) -> None:
        QMessageBox.information(self, "Project file", "Not implemented yet")
        return

    def SaveAsProject(self) -> None:
        QMessageBox.information(self, "Project file", "Not implemented yet")
        return

    def CloseProject(self) -> None:
    # Manage close de project: empty runtime variables, etc.
        if not self.projectOpened:
            QMessageBox.information(self, "Project file", "No QCrocoFlow project yet opened")
            return
        ans = QMessageBox.question(self, "Project file", f"Do you really want to close {self.projectName} project ?", \
                             buttons=QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, \
                             defaultButton = QMessageBox.StandardButton.No)
        if ans == QMessageBox.StandardButton.Yes:
            # TODO: manage cleanup variables here
            self.SetToDefaultVariableValue('PROJECT')
            self.saveProjectAction.setEnabled(False)
            self.saveAsProjectAction.setEnabled(False)
        return

    def WorkingDirectory(self) -> None:
        wkDir = QFileDialog.getExistingDirectory(self, "Select a working directory", self.projectDirectory,\
                                                 QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)
        if not wkDir:
            QMessageBox.information(self, "Set working directory", f"No new working directory\nCurrent working directory is {self.currentWorkingDIrectory}")
            return
        self.currentWorkingDIrectory = wkDir
        self.iface.messageBar().pushMessage("New working directory selected", f"{self.currentWorkingDIrectory}", level=Qgis.Info)
        return
    def NewGrid(self) -> None:
    # Creation of a new grid
        self.grdDlg = qcrocoflow_crocogridDialog(self.iface, parent=self)
        self.grdDlg.show()
        return

    def OpenGrid(self) -> None:
        # Define the database
        script_dir = os.path.dirname(os.path.abspath(__file__))  # Get the directory of the current script
        db_path = os.path.join(script_dir, "project", "Grid.db")  # Get the path of the database relative to the script
        QMessageBox.information(self, "Database Path", "The database path is: " + db_path)
        db = QSqlDatabase.addDatabase('QSQLITE')
        db.setDatabaseName(db_path)
        if not db.open():
            QMessageBox.critical(self, "Database Error", db.lastError().text())
            return

        query = QSqlQuery(db)
        query.exec_(
            "SELECT title FROM Grid")  #

        # Récupérez les résultats de la requête
        items = []
        while query.next():
            items.append(query.value(0))

        item, ok = QInputDialog.getItem(self, "Open an project", "Select an project:", items, 0, False)
        if ok and item:
            # Requête pour obtenir les détails du projet sélectionné
            query = QSqlQuery(db)
            query.prepare("SELECT * FROM Grid WHERE title = ?")
            query.addBindValue(item)
            query.exec_()
            if query.next():
                # Récupérez les valeurs de la base de données
                directory = query.value(1)
                grdname = query.value(2)
                dl = query.value(3)
                hmin = query.value(4)
                topo = query.value(5)
                lat_min = query.value(6)
                lat_max = query.value(7)
                lon_min = query.value(8)
                lon_max = query.value(9)

                # Open grid dialog
                self.grdDlg = qcrocoflow_crocogridDialog(self.iface, parent=self)
                self.grdDlg.show()

                # Mettez à jour les variables
                self.grdDlg.Environnement_2.setText(directory)
                self.grdDlg.gridprojecttitleLineEdit.setText(item)
                self.grdDlg.gridnameLineEdit.setText(grdname)
                self.grdDlg.dlDoubleSpin.setValue(float(dl))
                self.grdDlg.hminSpinBox.setValue(hmin)
                self.grdDlg.topodirLineEdit.setText(topo)
                self.grdDlg.latminLineEdit.setText(str(lat_min))
                self.grdDlg.latmaxLineEdit.setText(str(lat_max))
                self.grdDlg.lonminLineEdit.setText(str(lon_min))
                self.grdDlg.lonmaxLineEdit.setText(str(lon_max))
            else:
                QMessageBox.warning(self, "No Data", "No data found for the selected project.")


    def ImportNetCDFGrid(self) -> None:
    # Import variables from a netCDF file to create raster or vector layers in QGIS
        openGridDlg = qcrocoflowCROCO2QGIS(self.currentWorkingDIrectory, self)
        if openGridDlg.exec():
            ncFile = openGridDlg.GetNetCDFFileName()
            varsDict = openGridDlg.GetDictOfVars() # A dictionary of selected variables is returned for each dimension
            coordsDict = openGridDlg.GetDictOfCoords() # A dictionary of selected coordinate variables
            if len(varsDict.keys()) == 0:
                QMessageBox.information(self, 'List of variables', f"No variable selected.")
                return
            self.AddNetCDFVariablesToMapset(ncFile, varsDict, coordsDict)
        return

    def AddNetCDFVariablesToMapset(self, _file: str, _varsDict: dict, _coordsDict: dict) -> None:
    # Add a raster to the current mapset based on a variable from a netCDF file
        try:
            ncdata = nc.Dataset(_file, 'r')
        except:
            QMessageBox.warning(self, 'Error', f"Can't open file {_file}")
            return

        # Get an existing group layer or define a new one into which add the raster layer(s)
        currentgrp = self.DefineGroup4Layer(_file)
        # Initialisation of object that will convert netCDF variables to raster layer SRC: WGS84 by default
        nc2r = netCDFtoRaster(QgsCoordinateReferenceSystem(EPSGWGS84))

        for k in _varsDict.keys():
            # Get the path of actual _file localisation and add the name of the file without its extension
            outputDirPath = os.path.join(os.path.dirname(_file), Path(_file).stem)
            # Create a new directory if not exist based on the previous path
            if not os.path.isdir(outputDirPath):
                os.mkdir(outputDirPath)
            rfilename = os.path.join(outputDirPath, f"{_varsDict[k]}.tif")
            # If the file exist, ask to keep or delete it
            if os.path.exists(rfilename):
                if QMessageBox.question(self, "Erase existing", f"File {rfilename} is present.\nErase it ?", \
                                        QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes) == QMessageBox.Yes:
                    os.remove(rfilename)  # delete the file
                    if int(k) > 4:
                        QMessageBox.warning(self, 'Error', f"{k}D dimension is not manage.")
                        return
                    extent = nc2r.createRaster(ncdata[_coordsDict['lon']][:], ncdata[_coordsDict['lat']][:], ncdata[_varsDict[k]][:],
                                               rfilename, int(k))
            else:
                if int(k) > 4:
                    QMessageBox.warning(self, 'Error', f"{k}D dimension is not manage.")
                    return
                extent = nc2r.createRaster(ncdata[_coordsDict['lon']][:], ncdata[_coordsDict['lat']][:], ncdata[_varsDict[k]][:],
                                               rfilename, int(k))
            # Some operations to initialise the layer for visualisation
            rlayer = QgsRasterLayer(rfilename)
            rlayer.setName(_varsDict[k])
            # Add the new layer to the group
            currentgrp.addLayer(rlayer)
            QgsProject.instance().addMapLayer(rlayer, False)
        ncdata.close()

    def DefineGroup4Layer(self, _file: str) -> tuple:
        root = QgsProject.instance().layerTreeRoot()
        grplist = [child for child in root.children() if child.nodeType() == 0]
        grpnames = [grpname.name() for grpname in grplist]
        if os.path.basename(_file) in grpnames:
            grpids = [index for (index, item) in enumerate(grpnames) if item == os.path.basename(_file)]
            if QMessageBox.information(self, 'Group exist',
                                       f"The group {os.path.basename(_file)} exist\nDo you want to delete it ?",
                                       QMessageBox.Yes | QMessageBox.No, \
                                       QMessageBox.Yes) == QMessageBox.Yes:
                for id in grpids:
                    root.removeChildNode(grplist[id])
                # Create a new group with the name of the selected netCDF file
                currentgrp = root.addGroup(os.path.basename(_file))
            else:
                # Current group still exist and is selected to add the new layer in it
                currentgrp = grplist[0]  # Should contains only one element
        else:
            # The group does not exist, create it
            currentgrp = root.addGroup(os.path.basename(_file))
        return currentgrp

    def NewSediment(self) -> None:
        def Close():
            if self.layout().itemAt(0):
                self.layout().itemAt(0).widget().deleteLater()
            return

        form_search = QWidget()

        layout = QGridLayout(form_search)
        layout.setContentsMargins(10,0,10,0)
        layout.setSpacing(20)

        search_term = QLineEdit()
        search_term.setPlaceholderText("Enter a search term")
        layout.addWidget(search_term, 0, 0)

        btn_search = QPushButton('Go')
        btn_search.clicked.connect(self.OpenSediment)
        layout.addWidget(btn_search, 0, 1)

        btn_close = QPushButton('Close')
        btn_close.clicked.connect(Close)
        layout.addWidget(btn_close, 1, 0)

        form_search.setLayout(layout)
        self.setWidget(form_search)
        self.iface.messageBar().pushMessage("New sediment netCDF file")
        return

    def OpenSediment(self) -> None:
        QMessageBox.information(self, "Project file", "Not implemented yet")
        return

    def closeEvent(self, event)-> None:
        self.closingPlugin.emit()
        event.accept()

    def GetCellIJ(self):
        #QMessageBox.information(self, "Project file", "Not implemented yet")
        #return
        self.iface.messageBar().pushMessage("Mouse tracking activated")
        canvas = self.iface.mapCanvas()
        canvas.setMapTool(self.pointTool)

    def ImportMarsResults(self) -> None:
        QMessageBox.information(self, "Project file", "Not implemented yet")
        return

    def add_message(self, message, color='black'):
        now = datetime.now()
        timestamp = now.strftime("%H:%M:%S")
        colored_message = f"<font color='{color}'>{timestamp}: {message}</font>"
        self.messagelogTextEdit.append(colored_message)


