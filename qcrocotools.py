# -*- coding: utf-8 -*-
"""
/***************************************************************************
 qcrocoflowDockWidget
                                 A QGIS plugin
 Plugin to manage CROCO intial and result files
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Emmanuel Poizot
        email                : emmanuel.poizot@lecnam.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import numpy as np
from osgeo import gdal

from PyQt5.QtWidgets import QDialog
from PyQt5.QtWidgets import QCheckBox, QVBoxLayout, QDialogButtonBox, QMessageBox

from qgis.core import QgsRasterLayer, QgsRectangle, QgsProcessing, QgsRasterBlock, Qgis, QgsRasterBandStats
from qgis import processing

import netCDF4 as nc

""" List of possible variables contain in netCDF croco files """
netCDFVariablesDict = {'GRIDVARLIST':['h','h0','hx','hy','mask_rho','f'],
                       'RHOVARLIST':['x_rho','y_rho','lon_rho','lat_rho','pm','pn','dndx','dmde', 'angle', 'mask_rho'],
                       'PSIVARLIST':['mask_psi','x_psi','y_psi','lon_psi','lat_psi'],
                       'UVVARLIST':['x_u','x_v','y_u','y_v','lon_u','lon_v','lat_u','lat_v']}

""" List of classical variables present in a croco grid netCDF file with rho coordinates
RHOVARLIST = ['x_rho','y_rho','lon_rho','lat_rho','pm','pn','dndx','dmde', 'angle']
"""

def DefnetCDFFileOutput(_filename, _lat, _lon, _nd) -> tuple:
    root = nc.Dataset(_filename, 'w')  # The dataset
    # The group
    #ensembles = fout.createGroup('UV')
    # The dimensions
    time = root.createDimension('time')
    lon = root.createDimension('lon', _lon)
    lat = root.createDimension('lat', _lat)
    z = root.createDimension('z', _nd)
    # The variables
    time = root.createVariable('time', 'f8', ('time',))
    lats = root.createVariable('lat', 'f4', ('lat',))
    lons = root.createVariable('lon', 'f4', ('lon',))
    u = root.createVariable('u', 'f4', ('time', 'z', 'lat', 'lon'))
    v = root.createVariable('v', 'f4', ('time', 'z', 'lat', 'lon'))
    w = root.createVariable('w', 'f4', ('time', 'z', 'lat', 'lon'))
    zeta = root.createVariable('zeta', 'f4', ('time', 'lat', 'lon'))
    # Attributs
    time._CoordinateAxisType = 'Time'
    time.time_origin = '01-JAN-1970 00:00:00'
    time.units = 'seconds since 1970-01-01T00:00:00.00Z'
    time.calendar = 'gregorian'
    lats.units = 'degrees_north'
    lats.standard_name = 'latitude'
    lons.units = 'degrees_east'
    lons.standard_name = 'longitude'
    root.geospatial_bounds_crs = 'EPSG:4326'
    root.geospatial_lat_units = 'degrees_north'
    root.geospatial_lon_units = 'degrees_east'
    u.units = 'meters second-1'
    u.standard_name = 'eastward_sea_water_velocity'
    u.long_name = 'u-velocity component'
    v.units = 'meters second-1'
    v.standard_name = 'northward_sea_water_velocity'
    v.long_name = 'v-velocity component'
    w.units = 'meters second-1'
    w.standard_name = 'northward_sea_water_velocity'
    w.long_name = 'w-velocity component'
    zeta.units = 'meters'
    return root

def extract_subdomain_index_original(lon_rho, lat_rho, lonr_min, lonr_max, latr_min, latr_max, gridvar) -> tuple:
    # extracts variable respecting the original roms format :
    # T[M,L]
    # U[M,L-1]
    # We take the first value of u just east of the first value of rho
    # We take the last value of u just west of the last value of rho
    # V[M-1,L]
    # we take the first value of v just north of the first value of rho
    # we take the last value of v just south of the last value of rho
    condition = (lon_rho >= lonr_min) & (lon_rho <= lonr_max) & (lat_rho >= latr_min) & (lat_rho <= latr_max)
    ligne, colonne = np.nonzero(condition)
    i_min, i_max, j_min, j_max = np.min(ligne), np.max(ligne), np.min(colonne), np.max(colonne)
    if gridvar == 'rho':
        i_min, i_max, j_min, j_max = np.min(ligne), np.max(ligne), np.min(colonne), np.max(colonne)
    elif gridvar == 'u':
        i_min, i_max, j_min, j_max = np.min(ligne), np.max(ligne), np.min(colonne), np.max(colonne) - 1
    elif gridvar == 'v':
        i_min, i_max, j_min, j_max = np.min(ligne), np.max(ligne) - 1, np.min(colonne), np.max(colonne)
    return i_min, i_max, j_min, j_max

def uv2rho_original_3d(var, vartype) -> tuple:
    # U[M,L-1]
    #zonal u at u point on one z level (2D horizontal)
    # We take the first value of u just east of the first value of rho
    # We take the last value of u just west of the last value of rho
    # V[M-1,L]
    #meridional v at v point on one z level (2D horizontal)
    # we take the first value of v just north of the first value of rho
    # we take the last value of v just south of the last value of rho
    if vartype == 'u':
        var_rho = 0.5 * (var[ :, :, 1:-1, :-1] + var[ :, :, 1:-1, 1:])
    elif vartype == 'v':
        var_rho = 0.5 * (var[ :, :, :-1, 1:-1] + var[ :, :, 1:, 1:-1])
    elif vartype == '2D':
        var_rho = var[1:-1, 1:-1]
    elif vartype == '2D+T':
        var_rho = var[:, 1:-1, 1:-1]
    else: # 3D+T (default)
        var_rho = var[:, :, 1:-1, 1:-1]
    return var_rho

def rho2q_extrapoints(lonr,latr,varr) -> tuple:
    # lonr[M,L]
    # zonal u at u point on one z level (2D horizontal)
    # var[M,L]
    # lonq[M-1,L-1]
    #meridional v at v point on one z level (2D horizontal)
    # we take the first value of v just north of the first value of rho
    # we take the last value of v just south of the last value of rho
    varq=0.25*(varr[:-1,:-1]+varr[:-1,1:]+varr[1:,:-1]+varr[1:,1:])
    lonq=0.25*(lonr[:-1,:-1]+lonr[:-1,1:]+lonr[1:,:-1]+lonr[1:,1:])
    latq=0.25*(latr[:-1,:-1]+latr[:-1,1:]+latr[1:,:-1]+latr[1:,1:])
    return lonq,latq,varq

def read_croco_grid(_ncInFile) -> tuple:
    ncroms=nc.Dataset(_ncInFile,'r')
    lonr=ncroms['lon_rho'][:]
    latr=ncroms['lat_rho'][:]
    ncroms.close()
    #Reconstruct missing values if necessary
    if np.any(lonr.mask==False):
        for i in range(np.shape(lonr)[1]):
            lonr[:,i]=np.min(lonr[:,i])
        for j in range(np.shape(latr)[0]):
            latr[j,:]=np.min(latr[j,:])
    #return lonr,latr,h,hc,theta_s,theta_b,N
    return lonr, latr, np.min(lonr), np.min(latr), np.max(lonr), np.max(latr)

def CreatenetCDFFile(_args, _datadict) -> None:
    X, Y = _datadict['lon'][:].shape
    x, Z ,x , x = _datadict['w'][:].shape
    ncfile = DefnetCDFFileOutput(_args, X, Y, Z)  # Y: lat and X: lon
    ncfile['time'][:] = _datadict['time']
    ncfile['lon'][:] = _datadict['lon'][0,:]
    ncfile['lat'][:] = _datadict['lat'][:,0]
    ncfile['u'][:] = _datadict['u']
    ncfile['v'][:] = _datadict['v']
    ncfile['w'][:] = _datadict['w']
    ncfile['zeta'][:] = _datadict['zeta']
    ncfile.close()

def GetFirstDateIndex(_nctime, _start) -> tuple:
    if not _start:
        return 0
    for i in range(len(_nctime)):
        if _nctime[i] >= _start:
            return i
    return 0

def GetLastDateIndex(_nctime, _end) -> tuple:
    if not _end:
        return len(_nctime) - 1
    for i in range(len(_nctime)):
        if _nctime[i] >= _end:
            return i
    return len(_nctime) - 1

class netcdfVariablesDlg(QDialog):
    """ Claas to manage dialog variables located in a netCDF file """
    def __init__(self, _variables):
        super(QDialog, self).__init__()
        assert isinstance(_variables, dict)
        layout = QVBoxLayout()
        self.varcheckboxlist = list()
        for var in _variables:
            if var.lower() in netCDFVariablesDict['GRIDVARLIST']:
                self.varcheckboxlist.append(QCheckBox(var, self))
                layout.addWidget(self.varcheckboxlist[-1])
        self.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        layout.addWidget(self.buttonBox)
        self.setLayout(layout)
        self.setWindowTitle("List of variables")

        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)

    def getCheckedVariableNameList(self) -> list:
        """ Check which variables are checked and return the list """
        retvarlistname = list()
        for chkbox in  self.varcheckboxlist:
            if chkbox.isChecked():
                retvarlistname.append(chkbox.text())
        return retvarlistname

class netCDFtoRaster():
    """ Class to manage rasters/grids from a netCDF file """
    def __init__(self, _crs):
        self.CRS = _crs

    def createRaster(self, _x, _y, _array, _varname) -> tuple:
        """ Create a raster from a variable located in a netCDF file"""
        # creating a constant raster which will be overwritten later
        extent = QgsRectangle()
        extent.setXMinimum(np.nanmin(_x[0,:]))
        extent.setYMinimum(np.nanmin(_y[:,0]))
        extent.setXMaximum(np.nanmax(_x[0,:]))
        extent.setYMaximum(np.nanmax(_y[:,0]))

        pxsize = np.nanmean(np.diff(_x[0,:]))
        pysize = np.nanmean(np.diff(_y[:,0]))
        ny, nx = _array.shape
        # gdal creation options
        #gdal.SetConfigOption('GDAL_TIFF_INTERNAL_MASK','YES')
        # Create the raster
        ds = gdal.GetDriverByName("GTiff").Create(_varname, xsize=nx, ysize=ny, bands=1, eType=gdal.GDT_Float64,
                                                  options=["TILED=YES"])
        ds.GetRasterBand(1).WriteArray(np.flip(_array,0))
        ds.SetProjection(self.CRS.toWkt())
        ds.GetRasterBand(1).GetStatistics(0, 1)
        ds.GetRasterBand(1).SetNoDataValue(-32768)
        ds.GetRasterBand(1).GetStatistics(0,1)
        ds.SetGeoTransform([extent.xMinimum(), pxsize, 0, extent.yMaximum(), 0, -pysize])
        ds.GetRasterBand(1).FlushCache()
        ds = None
        del ds

        return extent

