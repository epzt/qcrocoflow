# -*- coding: utf-8 -*-
"""
/***************************************************************************
 qcrocoflow_crocogridDialog
                                 Aa QGIS plugin
 qcrocoflow_crocogrid
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-05-03
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Jonathan nejmann
        email                : jonathan.nejmann@hotmail.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# Built-in module
from datetime import datetime
import numpy as np

# PyQt5 modules for interacting with a SQLite database
from PyQt5.QtSql import QSqlDatabase, QSqlQuery
# PyQt5 modules for creating a file dialog, a message box, labels, and box layouts
from PyQt5.QtWidgets import QFileDialog, QMessageBox, QLabel, QVBoxLayout
# QGIS core modules for working with coordinate reference systems, geographic features, geometric shapes, points, rectangles,
# geographic projects, raster layers, coordinate transformations, vector layers, fill symbols, and single symbol renderers
from qgis.core import (QgsCoordinateReferenceSystem, QgsFeature, QgsGeometry,
                       QgsPointXY, QgsRectangle,
                       QgsProject, QgsRasterLayer, QgsCoordinateTransform, QgsVectorLayer, QgsFillSymbol, QgsSingleSymbolRenderer, QgsSettings)
# QGIS module for creating a map tool that allows the user to select a rectangular area on the map
from qgis.gui import QgsMapToolExtent
# PyQt5 module for working with Qt's user interface compiler
from PyQt5 import uic
# PyQt5 modules for working with dates, URL, and desktop services
from PyQt5.QtCore import QDate, Qt, QUrl
from PyQt5.QtGui import QDesktopServices
# PyQt5 modules for creating a dialog and push buttons
from PyQt5.QtWidgets import QDialog, QPushButton
# Local modules for creating a grid, making bulk and tides files for croco
from .Grid.make_grid import make_grid_function
from .Bulk.ERA5_request import ERA5_request_script
from .Tides.make_tides import make_tides_script
from .Bulk.make_bulk import *

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'qcrocoflow_crocogrid_dialog_base.ui'))


class qcrocoflow_crocogridDialog(QDialog, FORM_CLASS):
#"class"
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(qcrocoflow_crocogridDialog, self).__init__(parent)
        self.era5_path = None
        self.directory = ""
        self.iface = iface
        self.parent = parent
        self.setupUi(self)
        self.load_topography_files()
        self.load_TPXO_path()
        self.Environnement_2.setToolTip("Bonjour")
        self.connect_signals_and_slots()
        #init Grid
        self.titre = ""
        self.grid_layer = None
        self.selected_extent = None
        self.dlDoubleSpin.setDecimals(1)
        self.dlDoubleSpin.setValue(0.0)
        self.dl = 0.0
        self.ddButton.setChecked(True)
        #initdate
        self.date_min = QDate()
        self.date_max = QDate()
        self.Ymax = None
        self.Mmax = None
        self.Dmax = None
        self.Ymin = None
        self.Mmin = None
        self.Dmin = None
        #initTides
        self.ROMSnames = self.create_ROMSnames_list()
        self.m2checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.n2checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.k2checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.k1checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.o1checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.p1checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.q1checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.mmcheckBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.mfcheckBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.m4checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.mn4checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.ms4checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.s2checkBox.stateChanged.connect(self.on_checkBox_state_changed)

        #initDatabase
        # Obtenir le chemin du script actuellement exécuté
        current_path = os.path.dirname(os.path.abspath(__file__))
        project_path = os.path.join(current_path, "..", "..", "BaseDon")
        # Vérifier si ce dossier existe, sinon le créer
        os.makedirs(project_path, exist_ok=True)
        self.db_path = os.path.join(project_path, "Grid.db")
        self.db = QSqlDatabase.addDatabase('QSQLITE')
        self.db.setDatabaseName(self.db_path)

        if not self.db.open():
            QMessageBox.critical(self, "Database Error", self.db.lastError().text())
        self.load_projects()
        self.selecttopoComboBox.currentIndexChanged.connect(self.select_bathymetry_file_from_combobox)

    #BATHYMETRIE
    def load_topography_files(self):
        settings = QgsSettings()
        files = settings.value("/topography_files", [])
        self.topography_files = files if files else []
        self.update_topography_combobox()

    def save_topography_files(self):
        settings = QgsSettings()
        settings.setValue("/topography_files", self.topography_files)


    def update_topography_combobox(self):
        # Try to disconnect the signal
        try:
            self.selecttopoComboBox.currentIndexChanged.disconnect()
        except TypeError:
            pass
        # Update the combobox
        self.selecttopoComboBox.clear()
        self.selecttopoComboBox.addItem("")  # Add an empty item at the start
        self.selecttopoComboBox.addItems(self.topography_files)
        # Reconnect the signal
        self.selecttopoComboBox.currentIndexChanged.connect(self.select_bathymetry_file_from_combobox)

    ###############################################################################################
    #                            CONNECT BUTTON TO FONCTION                                           #
    ###############################################################################################

    def connect_signals_and_slots(self):
        self.selectenvButton.clicked.connect(self.select_work_environment_directory)
        self.gridprojecttitleLineEdit.textChanged.connect(self.on_gridprojecttitle_text_changed)
        self.gridnameLineEdit.textChanged.connect(self.on_gridname_text_changed)
        self.dlDoubleSpin.editingFinished.connect(self.on_dl_b_text_changed)
        self.selecttopoButton.clicked.connect(self.select_topography_file)
        self.savevariablesButton.clicked.connect(self.save_variables_to_file)
        self.selectzoneButton.clicked.connect(self.select_zone)
        self.lonminLineEdit.textChanged.connect(self.update_grid)
        self.lonmaxLineEdit.textChanged.connect(self.update_grid)
        self.latminLineEdit.textChanged.connect(self.update_grid)
        self.latmaxLineEdit.textChanged.connect(self.update_grid)
        self.ddButton.clicked.connect(self.update_coordinates_DD)
        self.dmButton.clicked.connect(self.update_coordinates_DM)
        self.dmsButton.clicked.connect(self.update_coordinates_DMS)
        self.gridexecuteButton.clicked.connect(self.on_execute_grid)
        self.selecttopoComboBox.currentIndexChanged.connect(self.select_bathymetry_file_from_combobox)
        self.opengridprojectComboBox.currentIndexChanged.connect(self.update_variables)
        #dates
        self.datestart.dateChanged.connect(self.on_date_changed)
        self.dateend.dateChanged.connect(self.on_date_changed)
        #Bulk
        self.ERA5pushButton.clicked.connect(self.open_era5_window)
        self.ERA5dwlButton.clicked.connect(self.run_era5_script)
        self.BulkexecuteButton.clicked.connect(self.on_execute_Bulk)
        self.selectERA5Button.clicked.connect(self.select_ERA5_file)
        #tides
        self.TPXO9pushButton.clicked.connect(self.open_TPXO9_window)
        self.TidesexecuteButton.clicked.connect(self.on_execute_Tides)
        self.selectTPXO9Button.clicked.connect(self.select_tpxo_file)

    def load_TPXO_path(self):
        """
         This function is responsible for loading the path of the TPXO file from the QGIS settings.
         If the TPXO file path is found, it updates the label.
        """
        settings = QgsSettings()
        self.TPXO_path = settings.value("/TPXO_path", "")
        # If a TPXO path is found
        if self.TPXO_path:
            # Update label with the path and set the color to green
            self.tpxoStatusLabel.setText(f"TPXO file loaded: {self.TPXO_path}")
            self.tpxoStatusLabel.setStyleSheet("color: green")
        else:
            # Update label with a no-file-loaded message and set the color to orange
            self.tpxoStatusLabel.setText("No TPXO file loaded")
            self.tpxoStatusLabel.setStyleSheet("color: orange")

    #INFORMATIONS ABOUT ERA5 Button
    def open_era5_link(self):
        """
        This function opens a link to the ERA5 API documentation in the default web browser.
        """
        link = QUrl("https://cds.climate.copernicus.eu/api-how-to")
        QDesktopServices.openUrl(link)

    # INFORMATION ABOUT TPXO9 Button
    def open_TPXO9_link(self):
        """
        This function opens a link to the TPXO9 products and registration page in the default web browser.
        """
        link = QUrl("https://www.tpxo.net/tpxo-products-and-registration")
        QDesktopServices.openUrl(link)

    ###############################################################################################
    #                           DEFINE WORKPLACE                                              #
    ###############################################################################################

    def select_work_environment_directory(self):
        """
        Function to open a dialog to select a directory for the working environment.
        """
        directory = QFileDialog.getExistingDirectory(self, "Select Environment Directory")
        # If a directory is selected
        if directory:
            # Update label with the directory
            self.Environnement_2.setText(directory)
            # Save the directory
            self.directory = directory
            # Add a message to the parent console
            self.parent.add_message("Le chemin d'accès est : " + directory, color='blue')

    ###############################################################################################
    #                            SELECT TITLE PROJECT                                           #
    ###############################################################################################

    def on_gridprojecttitle_text_changed(self, text):
        """
        Function to update 'titre' when the text in the 'gridprojecttitle' text box changes.
        """
        self.titre = text

    ###############################################################################################
    #                              Grid Name                                                      #
    ###############################################################################################

    def on_gridname_text_changed(self, text):
        """
        Function to ensure the 'grdname' ends with '.nc' when the text in the 'gridname' text box changes
        """
        if not text.endswith('.nc'):
            text += '.nc'
        self.grdname = text

    ###############################################################################################
    #                              Grid Résolution                                               #
    ###############################################################################################

    def on_dl_b_text_changed(self):
        """
        Function to convert the text in the 'dlDoubleSpin' text box to a float when it changes
        """
        text = self.dlDoubleSpin.text()
        try:
            # Convert the text to a float
            self.dl = float(text)
            # Update the grid
            self.update_grid()
        except ValueError:
            # If the text can't be converted to a float, set 'dl' to 0.0 and display a warning
            self.dl = 0.0
            self.parent.add_message("Warning! the resolution of the grid must be greater than 0.", color='red')

    ###############################################################################################
    #                                          Dates                                              #
    ###############################################################################################
    def on_date_changed(self):
        """
        Function to extract the year, month, and day from the selected dates when they change.
        """
        # Get the selected dates
        self.date_min = self.datestart.date()
        self.date_max = self.dateend.date()

        # Extract the year, month, and day from each date
        self.Ymin = self.date_min.year()
        self.Mmin = self.date_min.month()
        self.Dmin = self.date_min.day()

        self.Ymax = self.date_max.year()
        self.Mmax = self.date_max.month()
        self.Dmax = self.date_max.day()


    ###############################################################################################
    #                                Select TOPOFILES                                             #
    ###############################################################################################


    def load_topography_file(self, file_name):
        """
        This function loads a topography file into the project and adds a message
        to the parent console. The file name is displayed in the 'topodirLineEdit'
        text box. The file is only loaded if it is not already in the project and
        its extension is either 'grd' or 'tif'.
        """
        if file_name:
            self.topodirLineEdit.setText(file_name)
            self.topo = file_name
            self.parent.add_message("Topography file:" + self.topo, color='blue')

            # Check file extension
            extension = file_name.split('.')[-1]
            if extension in ['grd', 'tif']:
                layer_name = os.path.basename(file_name)  # Get the base name of the file
                # Check if layer already exists
                if not QgsProject.instance().mapLayersByName(layer_name):
                    layer = QgsRasterLayer(file_name, layer_name)  # Use the base name as the layer name
                    if not layer.isValid():
                        print("Layer failed to load!")
                    else:
                        # Check CRS
                        if not layer.crs().authid():
                            layer.setCrs(QgsCoordinateReferenceSystem("EPSG:4326"))  # Set the CRS to WGS84
                            msg = QMessageBox()
                            msg.setIcon(QMessageBox.Warning)
                            msg.setText(
                                "CRS not detected, automatically set to WGS84 (EPSG:4326). Please verify this is correct.")
                            msg.setWindowTitle("CRS not detected")
                            msg.exec_()

                    # Add the layer regardless of its validity or CRS
                    QgsProject.instance().addMapLayer(layer)

    # ------------------------------------------------------------------#

    def select_topography_file(self):
        """
        This function opens a file dialog to select a topography file.
        The selected file is then loaded into the project and added to
        the list of topography files if it is not already in the list.
        """
        options = QFileDialog.Options()
        options |= QFileDialog.ReadOnly
        file_filter = "Topography files (*.nc *.tif *.grd);;All files (*)"
        file_name, _ = QFileDialog.getOpenFileName(self, "Select Topography File", "", file_filter, options=options)

        if file_name:
            # Set the line edit text and save the file name
            self.load_topography_file(file_name)

            # Add file to the list and save it
            if file_name not in self.topography_files:
                self.topography_files.append(file_name)
                self.save_topography_files()
                self.update_topography_combobox()

    # ------------------------------------------------------------------#

    def select_bathymetry_file_from_combobox(self):
        """
        This function loads a topography file selected from the 'selecttopoComboBox'
        into the project.
        """
        file_name = self.selecttopoComboBox.currentText()

        if file_name:
            self.load_topography_file(file_name)

    ###############################################################################################
    #                          Select zone                                                        #
    ###############################################################################################
    def select_zone(self):
        """
        This function sets a map tool for the canvas that allows the user to
        select a rectangular area on the map. Once an area is selected,
        it connects to the 'on_extent_changed' slot to handle the new selection.
        """
        # Instantiate a new map tool that lets the user draw a rectangle on the map
        self.map_tool = QgsMapToolExtent(self.iface.mapCanvas())
        # Set the map tool on the canvas
        self.iface.mapCanvas().setMapTool(self.map_tool)
        # Connect the extentChanged signal to the 'on_extent_changed' slot
        self.map_tool.extentChanged.connect(self.on_extent_changed)

    # ------------------------------------------------------------------#

    def on_extent_changed(self, extent):
        """
        This function is a slot that gets called when the user draws a new rectangle
        on the map. It transforms the coordinates of the rectangle to EPSG:4326
        (WGS84) and updates the text fields in the UI with these values.
        """
        # Save the selected extent
        self.selected_extent = extent
        # Define a coordinate transform that will transform coordinates from the project CRS to EPSG:4326 (WGS84)
        transform_4326 = QgsCoordinateTransform(QgsProject.instance().crs(), QgsCoordinateReferenceSystem('EPSG:4326'),
                                                QgsProject.instance())
        # Transform the extent to EPSG:4326
        extent = transform_4326.transformBoundingBox(extent)
        # Get the minimum and maximum longitude and latitude values
        lon_min = extent.xMinimum()
        lon_max = extent.xMaximum()
        lat_min = extent.yMinimum()
        lat_max = extent.yMaximum()
        # Update the text fields in the UI with the new coordinates
        self.lonminLineEdit.setText(str(lon_min))
        self.lonmaxLineEdit.setText(str(lon_max))
        self.latminLineEdit.setText(str(lat_min))
        self.latmaxLineEdit.setText(str(lat_max))
        # Define a coordinate transform that will transform coordinates from EPSG:4326 (WGS84) to the project CRS
        transform_project_crs = QgsCoordinateTransform(QgsCoordinateReferenceSystem('EPSG:4326'),
                                                       QgsCoordinateReferenceSystem('EPSG:3857'),
                                                       QgsProject.instance())
        # Transform the coordinates back to the project CRS
        lon_min, lat_min = transform_project_crs.transform(
            QgsPointXY(lon_min, lat_min)).x(), transform_project_crs.transform(QgsPointXY(lon_min, lat_min)).y()
        lon_max, lat_max = transform_project_crs.transform(
            QgsPointXY(lon_max, lat_max)).x(), transform_project_crs.transform(QgsPointXY(lon_max, lat_max)).y()
        # Save the transformed coordinates for later use
        self.lon_min = lon_min
        self.lon_max = lon_max
        self.lat_min = lat_min
        self.lat_max = lat_max
        # Store these values in the selected_extent for grid creation
        self.selected_extent = QgsRectangle(lon_min, lat_min, lon_max, lat_max)
        # Call the 'create_grid' function to create a new grid with the selected extent
        self.create_grid()

    # ------------------------------------------------------------------#
    def create_grid(self):
        """
        This function creates a grid based on the selected extent and resolution.
        If a grid already exists, it removes it before creating a new one.
        If no extent is selected or the resolution is not positive, it does not
        create a grid.
        """
        # If a grid layer already exists, remove it from the map
        if self.grid_layer is not None:
            QgsProject.instance().removeMapLayer(self.grid_layer.id())
            self.grid_layer = None
        # Ensure there is a selected extent and the resolution is positive
        if self.selected_extent is None or self.dl <= 0:
            if self.dl <= 0:
                self.parent.add_message("Warning! The resolution of the grid must be greater than 0.", color='red')
            return
        # Get the minimum and maximum latitude and longitude values of the selected extent
        lat_min = self.selected_extent.yMinimum()
        lat_max = self.selected_extent.yMaximum() + self.dl
        lon_min = self.selected_extent.xMinimum()
        lon_max = self.selected_extent.xMaximum() + self.dl
        # Create arrays of latitude and longitude values for the grid
        latitudes = np.arange(lat_min, lat_max, self.dl)
        longitudes = np.arange(lon_min, lon_max, self.dl)
        # Call the 'add_grid_to_map' function to add the grid to the map
        self.add_grid_to_map(latitudes, longitudes)

    # ------------------------------------------------------------------#

    def add_grid_to_map(self, latitudes, longitudes):
        """
        This function creates a grid layer and adds it to the map. The grid is made
        up of polygons representing each cell of the grid. The polygons are transparent
        with a black border.
        """
        # Create a memory layer to hold the grid
        grid_layer = QgsVectorLayer("Polygon?crs=epsg:3857", "grid", "memory")
        # Create a new simple fill symbol
        symbol = QgsFillSymbol.createSimple({'color': '255,255,255,0', 'outline_color': '0,0,0'})
        # The 'color' option sets the fill color. '255,255,255,0' is transparent.
        # The 'outline_color' option sets the color of the border. '0,0,0' is black.
        # Apply the symbol to the layer
        renderer = QgsSingleSymbolRenderer(symbol)
        grid_layer.setRenderer(renderer)
        provider = grid_layer.dataProvider()
        # Begin the editing session for the grid layer
        grid_layer.startEditing()
        # Add the latitude lines to the grid
        for i in range(len(latitudes) - 1):
            for j in range(len(longitudes) - 1):
                feature = QgsFeature()
                polygon = QgsGeometry.fromPolygonXY([
                    [QgsPointXY(longitudes[j], latitudes[i]),
                     QgsPointXY(longitudes[j + 1], latitudes[i]),
                     QgsPointXY(longitudes[j + 1], latitudes[i + 1]),
                     QgsPointXY(longitudes[j], latitudes[i + 1]),
                     QgsPointXY(longitudes[j], latitudes[i])]])
                feature.setGeometry(polygon)
                provider.addFeature(feature)

        # Commit the changes to the grid layer and update its extents
        grid_layer.commitChanges()
        grid_layer.updateExtents()
        # Add the grid layer to the map
        QgsProject.instance().addMapLayer(grid_layer)
        # Update self.grid_layer with the new grid
        self.grid_layer = grid_layer

    # ------------------------------------------------------------------#

    def update_grid(self):
        """
        This function updates the grid based on the current text field values.
        It will not update the grid if any of the text fields do not contain valid floats.
        """
        try:
            lat_min = float(self.latminLineEdit.text())
            lat_max = float(self.latmaxLineEdit.text())
            lon_min = float(self.lonminLineEdit.text())
            lon_max = float(self.lonmaxLineEdit.text())
        except ValueError:
            # One of the text fields does not contain a valid float
            return

        # Define a coordinate transform that will transform coordinates from EPSG:4326 (WGS84) to EPSG:3857
        transform_3857 = QgsCoordinateTransform(QgsCoordinateReferenceSystem('EPSG:4326'),
                                                QgsCoordinateReferenceSystem('EPSG:3857'),
                                                QgsProject.instance())

        # Transform the coordinates to EPSG:3857
        lon_min, lat_min = transform_3857.transform(QgsPointXY(lon_min, lat_min)).x(), transform_3857.transform(
            QgsPointXY(lon_min, lat_min)).y()
        lon_max, lat_max = transform_3857.transform(QgsPointXY(lon_max, lat_max)).x(), transform_3857.transform(
            QgsPointXY(lon_max, lat_max)).y()

        # Update the class attributes with the new coordinates
        self.lon_min = lon_min
        self.lon_max = lon_max
        self.lat_min = lat_min
        self.lat_max = lat_max

        # Store these values in the selected_extent for grid creation
        self.selected_extent = QgsRectangle(lon_min, lat_min, lon_max, lat_max)

        # Call the 'create_grid' function to create a new grid with the updated extent
        self.create_grid()

    ###############################################################################################
    #                            DD/DMS/DM                                                       #
    ###############################################################################################
    def update_coordinates_DD(self):
        """
        This function Update coordinates to Decimal Degrees (DD) format.
        """
        self.lonminLineEdit.setText(str(self.selected_extent.xMinimum()))
        self.lonmaxLineEdit.setText(str(self.selected_extent.xMaximum()))
        self.latminLineEdit.setText(str(self.selected_extent.yMinimum()))
        self.latmaxLineEdit.setText(str(self.selected_extent.yMaximum()))

    # ------------------------------------------------------------------#
    def update_coordinates_DM(self):
        """
        Update coordinates to Degrees and Decimal Minutes (DM) format.
        """
        self.lonminLineEdit.setText(self.deg_to_dm(self.selected_extent.xMinimum()))
        self.lonmaxLineEdit.setText(self.deg_to_dm(self.selected_extent.xMaximum()))
        self.latminLineEdit.setText(self.deg_to_dm(self.selected_extent.yMinimum()))
        self.latmaxLineEdit.setText(self.deg_to_dm(self.selected_extent.yMaximum()))

    # ------------------------------------------------------------------#
    def update_coordinates_DMS(self):
        """
        Update coordinates to Degrees, Minutes, and Seconds (DMS) format.
        """
        self.lonminLineEdit.setText(self.deg_to_dms(self.selected_extent.xMinimum()))
        self.lonmaxLineEdit.setText(self.deg_to_dms(self.selected_extent.xMaximum()))
        self.latminLineEdit.setText(self.deg_to_dms(self.selected_extent.yMinimum()))
        self.latmaxLineEdit.setText(self.deg_to_dms(self.selected_extent.yMaximum()))

    # ------------------------------------------------------------------#

    def deg_to_dm(self, deg):
        """
        Convert deg to degres minutes.
        """
        d = int(deg)
        m = abs(deg - d) * 60
        return "{}°{}'".format(d, m)
    # ------------------------------------------------------------------#
    def deg_to_dms(self, deg):
        """
        Convert deg to degres minutes sec.
        """
        d = int(deg)
        m_temp = abs(deg - d) * 60
        m = int(m_temp)
        s = (m_temp - m) * 60
        return "{}°{}'{}\"".format(d, m, s)


    ###############################################################################################
    #                                        TIDES                                                #
    ###############################################################################################

    def open_TPXO9_window(self):
        """
        This function creates a dialog window that displays a message informing the user
        to subscribe to the TPXO9 model by submitting a request. It also provides a link
        to the website for more information and a button to open the link.
        """
        # Create a QDialog object
        TPXO9_window = QDialog(self)
        TPXO9_window.setWindowTitle("ERA5 Window")

        # Create a QLabel widget to display the message in English
        message_label = QLabel(
            "To use the TPXO9 model, you must subscribe to the model by submitting a request, all the information is available here: <a href='https://www.tpxo.net/tpxo-products-and-registration'>HERE</a>.")
        message_label.setOpenExternalLinks(True)
        message_label.setAlignment(Qt.AlignCenter)

        # Create a button to open the link
        link_button = QPushButton("Open Link")
        link_button.clicked.connect(self.open_TPXO9_link)

        # Create a vertical layout for the window and add the widgets
        layout = QVBoxLayout(TPXO9_window)
        layout.addWidget(message_label)
        layout.addWidget(link_button)

        # Show the window
        TPXO9_window.exec_()

    # ------------------------------------------------------------------#
    def select_tpxo_file(self):
        """
        This function allows the user to select a directory that contains the TPXO model file.
        After a directory is selected, the path is saved to QGIS settings, and the status label
        is updated to show whether the file has been loaded or not.
        """
        directory_path = QFileDialog.getExistingDirectory(self, "Select directory")

        if directory_path:
            self.TPXO_path = directory_path
            # Save the TPXO_path to QGIS settings
            settings = QgsSettings()
            settings.setValue("/TPXO_path", self.TPXO_path)
            # Set the label text to 'Loaded' and the color to green
            self.tpxoStatusLabel.setText(f"TPXO file loaded: {self.TPXO_path}")
            self.tpxoStatusLabel.setStyleSheet("color: green")
        else:
            # Set the label text to 'Not Loaded' and the color to orange
            self.tpxoStatusLabel.setText("TPXO File: Not Loaded")
            self.tpxoStatusLabel.setStyleSheet("color: orange")

    # ------------------------------------------------------------------#

    def create_ROMSnames_list(self):
        """
        This function creates a list of selected harmonics based on the state of the checkboxes
        in the user interface. It creates a dictionary mapping harmonic names to their corresponding
        checkboxes, then iterates over this dictionary to check if the checkbox is selected.
        If it is, the harmonic name is added to a list. The function then returns this list.
        """
        harmonics_checkBoxes = {
            'm2': self.m2checkBox,
            'n2': self.n2checkBox,
            'k2': self.k2checkBox,
            'k1': self.k1checkBox,
            'o1': self.o1checkBox,
            'p1': self.p1checkBox,
            'q1': self.q1checkBox,
            'mm': self.mmcheckBox,
            'mf': self.mfcheckBox,
            'm4': self.m4checkBox,
            'mn4': self.mn4checkBox,
            'ms4': self.ms4checkBox,
            's2': self.s2checkBox,
        }

        # Create a list to hold the names of selected harmonics
        self.ROMSnames = []
        # Iterate over the dictionary
        for harmonic, checkBox in harmonics_checkBoxes.items():
            # If the checkBox is checked, add the harmonic name to the list
            if checkBox.isChecked():
                self.ROMSnames.append(harmonic)
        print(self.ROMSnames)
        # Return the list of selected harmonics
        return self.ROMSnames
     # ------------------------------------------------------------------#
    def on_checkBox_state_changed(self):
        """
        This function is a handler for when the state of the checkboxes changes. It updates the
        list of selected harmonics by calling the 'create_ROMSnames_list' function.
        """
        self.ROMSnames = self.create_ROMSnames_list()

     # ------------------------------------------------------------------#

    def on_execute_Tides(self):
        """
        This function triggers the interpolation of tides based on selected harmonics, simulation
        length, and other parameters. It retrieves the selected date range, harmonics, grid file
        path, and TPXO model file path, then calls a separate function 'make_tides_script' to
        perform the tide calculations.
        """
        #Init date for tides
        self.date_min = self.datestart.date()
        # Get the year, month, and day from self.date_min
        year = self.date_min.year()
        month = self.date_min.month()
        day = self.date_min.day()
        # Use them to create a datetime object
        date_min_datetime = datetime(year, month, day)
        # Suppose self.date_min and self.date_max are set previously in your code
        date_min = self.datestart.date()
        date_max = self.dateend.date()
        # Calculate the number of days between self.date_min and self.date_max
        lengthSim = date_min.daysTo(date_max)
        harmoniques = self.ROMSnames
        croco_grd = self.grdname_full_path
        TPXO_path = self.TPXO_path
        grdname = self.gridnameLineEdit.text()
        directory = self.directory
        make_tides_script(TPXO_path, croco_grd, harmoniques, lengthSim, date_min_datetime, grdname, directory)

    ###############################################################################################
    #                                          BULK                                               #
    ###############################################################################################

    def open_era5_window(self):
        """
        This function creates a dialog window that displays a message informing the user
        to create an API file to use the ERA5 model. It also provides a link to the website
        for more information and a button to open the link.
        """
        # Create a new dialog window
        era5_window = QDialog(self)
        era5_window.setWindowTitle("ERA5 Window")
        # Create a QLabel widget to display the message in English
        message_label = QLabel(
            "To use the ERA5 model, you must first create your API file. All the information is available <a href='https://cds.climate.copernicus.eu/api-how-to'>HERE</a>.")
        message_label.setOpenExternalLinks(True)
        message_label.setAlignment(Qt.AlignCenter)
        # Create a button to open the link
        link_button = QPushButton("Open Link")
        link_button.clicked.connect(self.open_era5_link)
        # Create a vertical layout for the window and add the widgets
        layout = QVBoxLayout(era5_window)
        layout.addWidget(message_label)
        layout.addWidget(link_button)
        # Show the window
        era5_window.exec_()
    # ------------------------------------------------------------------#
    def run_era5_script(self):
        """
        This function initiates the execution of the ERA5 request script.
        It fetches the required parameters such as the directory, title, grid name,
        latitude and longitude boundaries, and time ranges from the user interface,
        and calls the 'ERA5_request_script' function with these parameters.
        """
        # Fetch the required parameters from the UI
        directory = self.Environnement_2.text()
        title = self.gridprojecttitleLineEdit.text()
        grdname = self.gridnameLineEdit.text() + '.nc'
        lon_min = float(self.lon_min)
        lon_max = float(self.lon_max)
        lat_min = float(self.lat_min)
        lat_max = float(self.lat_max)
        Ymax = self.Ymax
        Ymin = self.Ymin
        Mmax = self.Mmax
        Mmin = self.Mmin
        # Call the ERA5 request script with the fetched parameters
        ERA5_request_script(title, lon_min, lon_max, lat_min, lat_max, directory, Ymin, Ymax, Mmin, Mmax)
    # ------------------------------------------------------------------#
    def select_ERA5_file(self):
        """
        This function allows the user to select a directory that contains the ERA5 model files.
        """
        directory_path = QFileDialog.getExistingDirectory(self, "Select directory")
        self.era5_path = directory_path
    def on_execute_Bulk(self):
        era5_dir = self.era5_path
        y_max = self.Ymax
        y_min = self.Ymin
        title = self.titre
        d_min = self.Dmin
        m_min = self.Mmin
        m_max = self.Mmax
        grid_dir = self.directory
        grdname = self.grdname_full_path
        mo_min = self.Mmin
        y_orig = 2000
        directory = self.directory
        main(era5_dir, m_min, grid_dir, title, grdname, d_min, directory)
    ###############################################################################################
    #                                    Save Variable                                            #
    ###############################################################################################

    def save_variables_to_file(self):
        directory = self.Environnement_2.text()
        title = self.gridprojecttitleLineEdit.text()
        grdname = self.gridnameLineEdit.text()
        dl = self.dlDoubleSpin.text()
        topo = self.topodirLineEdit.text()
        lat_min = self.latminLineEdit.text()
        lat_max = self.latmaxLineEdit.text()
        lon_min = self.lonminLineEdit.text()
        lon_max = self.lonmaxLineEdit.text()
        if not self.titre:
            QMessageBox.warning(self, "Warning", "Il manque la variable: titre")
            return
        if not directory:
            QMessageBox.warning(self, "Warning", "Il manque la variable: environment_directory")
            return
        if not grdname:
            QMessageBox.warning(self, "Warning", "Il manque la variable: grdname")
            return

        ###############################################################################################
        #                                  Create SQL                                                 #
        ###############################################################################################

        # Create and configure the database
        db = QSqlDatabase.addDatabase('QSQLITE')
        db.setDatabaseName(self.db_path)

        if not db.open():
            QMessageBox.critical(self, "Database Error", db.lastError().text())
            return

        query = QSqlQuery()

        sql = """
                CREATE TABLE IF NOT EXISTS Grid (
                    title TEXT PRIMARY KEY,
                    directory TEXT,
                    grdname TEXT,
                    dl REAL,
                    topo TEXT,
                    lat_min REAL,
                    lat_max REAL,
                    lon_min REAL,
                    lon_max REAL
                )
                """

        if not query.exec_(sql):
            QMessageBox.critical(self, "Database Error", query.lastError().text())
            return

        sql = """
                INSERT OR REPLACE INTO Grid 
                (title, directory, grdname, dl, topo, lat_min, lat_max, lon_min, lon_max)
                VALUES 
                (?, ?, ?, ?, ?, ?, ?, ?, ?)
                """

        query.prepare(sql)
        query.addBindValue(title)
        query.addBindValue(directory)
        query.addBindValue(grdname)
        query.addBindValue(dl)
        query.addBindValue(topo)
        query.addBindValue(lat_min)
        query.addBindValue(lat_max)
        query.addBindValue(lon_min)
        query.addBindValue(lon_max)

        if not query.exec_():
            QMessageBox.critical(self, "Database Error", query.lastError().text())
            return

        QMessageBox.information(self, "Information", "Variables saved to the file and database.")

    ######################
    # Grid.exe
    ######################

    def on_execute_grid(self):
        directory = self.Environnement_2.text()
        title = self.gridprojecttitleLineEdit.text()
        grdname = self.gridnameLineEdit.text() + '.nc'
        lon_min = float(self.lon_min)
        lon_max = float(self.lon_max)
        lat_min = float(self.lat_min)
        lat_max = float(self.lat_max)
        dl = float(self.dlDoubleSpin.text())
        topo = self.topodirLineEdit.text()

        self.grdname_full_path = make_grid_function(title, grdname, lon_min, lon_max, lat_min, lat_max, dl, topo, directory)
        print(self.grdname_full_path)

    ####################
    # Open project
    ##################
    def load_projects(self):
        # Execute a request for get all titles of projects
        query = QSqlQuery(self.db)
        query.exec_("SELECT title FROM Grid")
        # clear ComboBox
        self.opengridprojectComboBox.clear()
        self.opengridprojectComboBox.addItem("")
        # Add each title to the ComboBox
        while query.next():
            primary_key = query.value(0)
            self.opengridprojectComboBox.addItem(primary_key)

    def update_variables(self, index):
        # Get title of selected project
        selected_title = self.opengridprojectComboBox.itemText(index)

        # Execut requete for get variables of selected projet
        query = QSqlQuery(self.db)
        query.prepare("SELECT * FROM Grid WHERE title = :title")
        query.bindValue(":title", selected_title)
        query.exec_()

        if query.next():
            title = query.value(1)
            directory = query.value(2)
            grdname = query.value(3)
            dl = query.value(4)
            topo = query.value(5)
            lat_min = query.value(6)
            lat_max = query.value(7)
            lon_min = query.value(8)
            lon_max = query.value(9)

            # MAJ variables
            self.Environnement_2.setText(directory)
            self.gridprojecttitleLineEdit.setText(selected_title)
            self.gridnameLineEdit.setText(grdname)
            self.dlDoubleSpin.setValue(float(dl))
            self.topodirLineEdit.setText(topo)
            self.latminLineEdit.setText(str(lat_min))
            self.latmaxLineEdit.setText(str(lat_max))
            self.lonminLineEdit.setText(str(lon_min))
            self.lonmaxLineEdit.setText(str(lon_max))

