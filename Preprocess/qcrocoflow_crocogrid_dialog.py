# -*- coding: utf-8 -*-
"""
/***************************************************************************
 qcrocoflow_crocogridDialog
                                 Aa QGIS plugin
 qcrocoflow_crocogrid
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-05-03
        git sha              : $Format:%H$
        copyright            : (C) 2023 by john nejmann
        email                : @
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from datetime import datetime

import numpy as np
from PyQt5.QtSql import QSqlDatabase, QSqlQuery
from PyQt5.QtWidgets import QFileDialog, QMessageBox, QLabel, QVBoxLayout
from qgis.core import (QgsCoordinateReferenceSystem, QgsFeature, QgsGeometry,
                       QgsPointXY, QgsRectangle,
                       QgsProject, QgsRasterLayer, QgsCoordinateTransform, QgsVectorLayer, QgsFillSymbol, QgsSingleSymbolRenderer, QgsSettings)

from qgis.gui import QgsMapToolExtent
from PyQt5 import uic
from PyQt5.QtCore import QDate, Qt, QUrl

from PyQt5.QtGui import QDesktopServices

from PyQt5.QtWidgets import QDialog, QPushButton

from .Grid.make_grid import make_grid_function
from .Bulk.ERA5_request import ERA5_request_script
from.Tides.make_tides import make_tides_script

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'qcrocoflow_crocogrid_dialog_base.ui'))


class qcrocoflow_crocogridDialog(QDialog, FORM_CLASS):

    def __init__(self, iface, parent=None):
        """Constructor."""
        super(qcrocoflow_crocogridDialog, self).__init__(parent)
        self.directory = ""
        self.iface = iface
        self.parent = parent
        self.setupUi(self)
        self.load_topography_files()
        self.load_TPXO_path()
        self.Environnement_2.setToolTip("Bonjour")
        self.connect_signals_and_slots()
        self.tabWidget.setCurrentIndex(2)
        #init Grid
        self.titre = ""
        self.grid_layer = None
        self.selected_extent = None
        self.dlDoubleSpin.setDecimals(1)
        self.dlDoubleSpin.setValue(0.0)
        self.dl = 0.0
        self.ddButton.setChecked(True)

        #initdate
        self.date_min = QDate()
        self.date_max = QDate()
        self.Ymax = None
        self.Mmax = None
        self.Dmax = None
        self.Ymin = None
        self.Mmin = None
        self.Dmin = None
        #init Tides
        self.ROMSnames = self.create_ROMSnames_list()
        self.m2checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.n2checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.k2checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.k1checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.o1checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.p1checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.q1checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.mmcheckBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.mfcheckBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.m4checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.mn4checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.ms4checkBox.stateChanged.connect(self.on_checkBox_state_changed)
        self.s2checkBox.stateChanged.connect(self.on_checkBox_state_changed)

        #initDatabase
        root_path = os.path.dirname(os.path.dirname(__file__))
        project_path = os.path.join(root_path, "project")
        self.db_path = os.path.join(project_path, "Grid.db")
        self.db = QSqlDatabase.addDatabase('QSQLITE')
        self.db.setDatabaseName(self.db_path)
        if not self.db.open():
            QMessageBox.critical(self, "Database Error", self.db.lastError().text())
        self.load_projects()
        self.selecttopoComboBox.currentIndexChanged.connect(self.select_bathymetry_file_from_combobox)

    def load_TPXO_path(self):
        settings = QgsSettings()
        self.TPXO_path = settings.value("/TPXO_path", "")
        if self.TPXO_path:
            self.tpxoStatusLabel.setText(f"TPXO file loaded: {self.TPXO_path}")
            self.tpxoStatusLabel.setStyleSheet("color: green")
        else:
            self.tpxoStatusLabel.setText("No TPXO file loaded")
            self.tpxoStatusLabel.setStyleSheet("color: orange")

    #BATHYMETRIE

    def load_topography_files(self):
        settings = QgsSettings()
        files = settings.value("/topography_files", [])
        self.topography_files = files if files else []
        self.update_topography_combobox()

    def save_topography_files(self):
        settings = QgsSettings()
        settings.setValue("/topography_files", self.topography_files)

    def update_topography_combobox(self):
        # Try to disconnect the signal
        try:
            self.selecttopoComboBox.currentIndexChanged.disconnect()
        except TypeError:
            pass

        # Update the combobox
        self.selecttopoComboBox.clear()
        self.selecttopoComboBox.addItems(self.topography_files)

        # Reconnect the signal
        self.selecttopoComboBox.currentIndexChanged.connect(self.select_bathymetry_file_from_combobox)

        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect

    ###################
    # connect boutons #
    ###################

    def connect_signals_and_slots(self):
        self.selectenvButton.clicked.connect(self.select_work_environment_directory)
        self.gridprojecttitleLineEdit.textChanged.connect(self.on_gridprojecttitle_text_changed)
        self.gridnameLineEdit.textChanged.connect(self.on_gridname_text_changed)
        self.dlDoubleSpin.editingFinished.connect(self.on_dl_b_text_changed)
        self.selecttopoButton.clicked.connect(self.select_topography_file)
        self.savevariablesButton.clicked.connect(self.save_variables_to_file)
        self.selectzoneButton.clicked.connect(self.select_zone)
        self.lonminLineEdit.textChanged.connect(self.update_grid)
        self.lonmaxLineEdit.textChanged.connect(self.update_grid)
        self.latminLineEdit.textChanged.connect(self.update_grid)
        self.latmaxLineEdit.textChanged.connect(self.update_grid)
        self.ddButton.clicked.connect(self.update_coordinates_DD)
        self.dmButton.clicked.connect(self.update_coordinates_DM)
        self.dmsButton.clicked.connect(self.update_coordinates_DMS)
        self.gridexecuteButton.clicked.connect(self.on_execute_grid)
        self.selecttopoComboBox.currentIndexChanged.connect(self.select_bathymetry_file_from_combobox)
        self.opengridprojectComboBox.currentIndexChanged.connect(self.update_variables)
        #dates
        self.datestart.dateChanged.connect(self.on_date_changed)
        self.dateend.dateChanged.connect(self.on_date_changed)
        #Bulk
        self.ERA5pushButton.clicked.connect(self.open_era5_window)
        self.ERA5dwlButton.clicked.connect(self.run_era5_script)
        #tides
        self.TPXO9pushButton.clicked.connect(self.open_TPXO9_window)
        self.TidesexecuteButton.clicked.connect(self.on_execute_Tides)
        self.selectTPXO9Button.clicked.connect(self.select_tpxo_file)

    def open_era5_link(self):
        link = QUrl("https://cds.climate.copernicus.eu/api-how-to")
        QDesktopServices.openUrl(link)

    def open_TPXO9_link(self):
        link = QUrl("https://www.tpxo.net/tpxo-products-and-registration")
        QDesktopServices.openUrl(link)

    ############
    # Workplace#
    ############

    def select_work_environment_directory(self):
        directory = QFileDialog.getExistingDirectory(self, "Select Environment Directory")
        if directory:
            self.Environnement_2.setText(directory)
            self.directory = directory
            self.parent.add_message("Le chemin d'accès est : " + directory, color='blue')

    ########
    # Title#
    ########

    def on_gridprojecttitle_text_changed(self, text):
        self.titre = text

    #############
    # Grid name#
    #############

    def on_gridname_text_changed(self, text):
        if not text.endswith('.nc'):
            text += '.nc'
        self.grdname = text

    ###############################################################################################
    #                              Grid Résolution                                               #
    ###############################################################################################

    def on_dl_b_text_changed(self):
        text = self.dlDoubleSpin.text()
        try:
            self.dl = float(text)
            self.update_grid()
        except ValueError:
            self.dl = 0.0
            self.parent.add_message("Warning! the resolution of the grid must be greater than 0.", color='red')

    ###############################################################################################
    #                                          Dates                                              #
    ###############################################################################################
    def on_date_changed(self):
        self.date_min = self.datestart.date()
        self.date_max = self.dateend.date()

        self.Ymin = self.date_min.year()
        self.Mmin = self.date_min.month()
        self.Dmin = self.date_min.day()

        self.Ymax = self.date_max.year()
        self.Mmax = self.date_max.month()
        self.Dmax = self.date_max.day()


    ###############################################################################################
    #                                Select TOPOFILES                                             #
    ###############################################################################################

    def load_topography_file(self, file_name):
        if file_name:
            self.topodirLineEdit.setText(file_name)
            self.topo = file_name
            self.parent.add_message("Topography file:" + self.topo, color='blue')

            # Check file extension
            extension = file_name.split('.')[-1]
            if extension in ['grd', 'tif']:
                layer_name = os.path.basename(file_name)  # Get the base name of the file
                # Check if layer already exists
                if not QgsProject.instance().mapLayersByName(layer_name):
                    layer = QgsRasterLayer(file_name, layer_name)  # Use the base name as the layer name
                    if not layer.isValid():
                        print("Layer failed to load!")
                    else:
                        QgsProject.instance().addMapLayer(layer)


    def select_topography_file(self):
        options = QFileDialog.Options()
        options |= QFileDialog.ReadOnly
        file_filter = "Topography files (*.nc *.tif *.grd);;All files (*)"
        file_name, _ = QFileDialog.getOpenFileName(self, "Select Topography File", "", file_filter, options=options)

        if file_name:
            # Set the line edit text and save the file name
            self.load_topography_file(file_name)

            # Add file to the list and save it
            if file_name not in self.topography_files:
                self.topography_files.append(file_name)
                self.save_topography_files()
                self.update_topography_combobox()

    def select_bathymetry_file_from_combobox(self):
        file_name = self.selecttopoComboBox.currentText()

        if file_name:
            self.load_topography_file(file_name)
    ###############################################################################################
    #                          Select zone                                                        #
    ###############################################################################################
    def select_zone(self):
        self.map_tool = QgsMapToolExtent(self.iface.mapCanvas())
        self.iface.mapCanvas().setMapTool(self.map_tool)
        self.map_tool.extentChanged.connect(self.on_extent_changed)

    # ------------------------------------------------------------------#
    def on_extent_changed(self, extent):
        self.selected_extent = extent
        # Define a coordinate transform that will transform coordinates from the project CRS to EPSG:4326 (WGS84)
        transform_4326 = QgsCoordinateTransform(QgsProject.instance().crs(), QgsCoordinateReferenceSystem('EPSG:4326'),
                                                QgsProject.instance())
        # Transform the extent to EPSG:4326
        extent = transform_4326.transformBoundingBox(extent)
        lon_min = extent.xMinimum()
        lon_max = extent.xMaximum()
        lat_min = extent.yMinimum()
        lat_max = extent.yMaximum()
        self.lonminLineEdit.setText(str(lon_min))
        self.lonmaxLineEdit.setText(str(lon_max))
        self.latminLineEdit.setText(str(lat_min))
        self.latmaxLineEdit.setText(str(lat_max))
        # Define a coordinate transform that will transform coordinates from EPSG:4326 (WGS84)
        transform_project_crs = QgsCoordinateTransform(QgsCoordinateReferenceSystem('EPSG:4326'),
                                                       QgsCoordinateReferenceSystem('EPSG:3857'),
                                                       QgsProject.instance())

        # Transform the coordinates back to the project CRS
        lon_min, lat_min = transform_project_crs.transform(
            QgsPointXY(lon_min, lat_min)).x(), transform_project_crs.transform(QgsPointXY(lon_min, lat_min)).y()
        lon_max, lat_max = transform_project_crs.transform(
            QgsPointXY(lon_max, lat_max)).x(), transform_project_crs.transform(QgsPointXY(lon_max, lat_max)).y()
        #transformed
        self.lon_min = lon_min
        self.lon_max = lon_max
        self.lat_min = lat_min
        self.lat_max = lat_max
        # Store these values in the selected_extent for grid creation
        self.selected_extent = QgsRectangle(lon_min, lat_min, lon_max, lat_max)
        self.create_grid()

    # ------------------------------------------------------------------#
    def create_grid(self):
        # If a grid layer already exists, remove it from the map
        if self.grid_layer is not None:
            QgsProject.instance().removeMapLayer(self.grid_layer.id())
            self.grid_layer = None

        # Ensure there is a selected extent
        if self.selected_extent is None or self.dl <= 0:
            if self.dl <= 0:
                self.parent.add_message("Warning! the resolution of the grid must be greater than 0.", color='red')
            return

        lat_min = self.selected_extent.yMinimum()
        lat_max = self.selected_extent.yMaximum() + self.dl
        lon_min = self.selected_extent.xMinimum()
        lon_max = self.selected_extent.xMaximum() + self.dl
        latitudes = np.arange(lat_min, lat_max, self.dl)
        longitudes = np.arange(lon_min, lon_max, self.dl)
        self.add_grid_to_map(latitudes, longitudes)

    # ------------------------------------------------------------------#
    def add_grid_to_map(self, latitudes, longitudes):
        # Create a memory layer to hold the grid
        grid_layer = QgsVectorLayer("Polygon?crs=epsg:3857", "grid", "memory")
        # Create a new simple fill symbol
        symbol = QgsFillSymbol.createSimple({'color': '255,255,255,0', 'outline_color': '0,0,0'})
        # The 'color' option sets the fill color. '255,255,255,0' is transparent.
        # The 'outline_color' option sets the color of the border. '0,0,0' is black.
        # Apply the symbol to the layer
        renderer = QgsSingleSymbolRenderer(symbol)
        grid_layer.setRenderer(renderer)
        provider = grid_layer.dataProvider()
        # Begin the editing session for the grid layer
        grid_layer.startEditing()
        # Add the latitude lines to the grid
        for i in range(len(latitudes) - 1):
            for j in range(len(longitudes) - 1):
                feature = QgsFeature()
                polygon = QgsGeometry.fromPolygonXY([
                    [QgsPointXY(longitudes[j], latitudes[i]),
                     QgsPointXY(longitudes[j + 1], latitudes[i]),
                     QgsPointXY(longitudes[j + 1], latitudes[i + 1]),
                     QgsPointXY(longitudes[j], latitudes[i + 1]),
                     QgsPointXY(longitudes[j], latitudes[i])]])
                feature.setGeometry(polygon)
                provider.addFeature(feature)

        # Commit the changes to the grid layer and update its extents
        grid_layer.commitChanges()
        grid_layer.updateExtents()

        # Add the grid layer to the map
        QgsProject.instance().addMapLayer(grid_layer)

        # Update self.grid_layer with the new grid
        self.grid_layer = grid_layer

    # ------------------------------------------------------------------#
    def update_grid(self):
        try:
            lat_min = float(self.latminLineEdit.text())
            lat_max = float(self.latmaxLineEdit.text())
            lon_min = float(self.lonminLineEdit.text())
            lon_max = float(self.lonmaxLineEdit.text())
        except ValueError:
            # One of the text fields does not contain a valid float
            return

        # Define a coordinate transform that will transform coordinates from EPSG:4326 (WGS84) to EPSG:3857
        transform_3857 = QgsCoordinateTransform(QgsCoordinateReferenceSystem('EPSG:4326'),
                                                QgsCoordinateReferenceSystem('EPSG:3857'),
                                                QgsProject.instance())

        # Transform the coordinates to EPSG:3857
        lon_min, lat_min = transform_3857.transform(QgsPointXY(lon_min, lat_min)).x(), transform_3857.transform(
            QgsPointXY(lon_min, lat_min)).y()
        lon_max, lat_max = transform_3857.transform(QgsPointXY(lon_max, lat_max)).x(), transform_3857.transform(
            QgsPointXY(lon_max, lat_max)).y()

        # Update the class attributes with the new coordinates
        self.lon_min = lon_min
        self.lon_max = lon_max
        self.lat_min = lat_min
        self.lat_max = lat_max

        # Store these values in the selected_extent for grid creation
        self.selected_extent = QgsRectangle(lon_min, lat_min, lon_max, lat_max)

        self.create_grid()

    ###############################################################################################
    #                            DD/DMS/DM                                                       #
    ###############################################################################################
    def update_coordinates_DD(self):
        # Update coordinates to Decimal Degrees (DD) format
        self.lonminLineEdit.setText(str(self.selected_extent.xMinimum()))
        self.lonmaxLineEdit.setText(str(self.selected_extent.xMaximum()))
        self.latminLineEdit.setText(str(self.selected_extent.yMinimum()))
        self.latmaxLineEdit.setText(str(self.selected_extent.yMaximum()))

    # ------------------------------------------------------------------#
    def update_coordinates_DM(self):
        # Update coordinates to Degrees and Decimal Minutes (DM) format
        self.lonminLineEdit.setText(self.deg_to_dm(self.selected_extent.xMinimum()))
        self.lonmaxLineEdit.setText(self.deg_to_dm(self.selected_extent.xMaximum()))
        self.latminLineEdit.setText(self.deg_to_dm(self.selected_extent.yMinimum()))
        self.latmaxLineEdit.setText(self.deg_to_dm(self.selected_extent.yMaximum()))

    # ------------------------------------------------------------------#
    def update_coordinates_DMS(self):
        # Update coordinates to Degrees, Minutes, and Seconds (DMS) format
        self.lonminLineEdit.setText(self.deg_to_dms(self.selected_extent.xMinimum()))
        self.lonmaxLineEdit.setText(self.deg_to_dms(self.selected_extent.xMaximum()))
        self.latminLineEdit.setText(self.deg_to_dms(self.selected_extent.yMinimum()))
        self.latmaxLineEdit.setText(self.deg_to_dms(self.selected_extent.yMaximum()))

    # ------------------------------------------------------------------#
    def deg_to_dm(self, deg):
        d = int(deg)
        m = abs(deg - d) * 60
        return "{}°{}'".format(d, m)

    # ------------------------------------------------------------------#
    def deg_to_dms(self, deg):
        d = int(deg)
        m_temp = abs(deg - d) * 60
        m = int(m_temp)
        s = (m_temp - m) * 60
        return "{}°{}'{}\"".format(d, m, s)


    ###############################################################################################
    #                                        TIDES                                                #
    ###############################################################################################

    def open_TPXO9_window(self):
        # Créez une nouvelle fenêtre de dialogue
        TPXO9_window = QDialog(self)
        TPXO9_window.setWindowTitle("ERA5 Window")

        # Créez un widget QLabel pour afficher le message en anglais
        message_label = QLabel(
            "To use the TPXO9 model, you must subscribe to the model by submitting a request, all the information is available here: <a href='https://www.tpxo.net/tpxo-products-and-registration'>HERE</a>.")
        message_label.setOpenExternalLinks(True)
        message_label.setAlignment(Qt.AlignCenter)

        # Créez un bouton pour ouvrir le lien
        link_button = QPushButton("Open Link")
        link_button.clicked.connect(self.open_TPXO9_link)

        # Créez un layout vertical pour la fenêtre et ajoutez les widgets
        layout = QVBoxLayout(TPXO9_window)
        layout.addWidget(message_label)
        layout.addWidget(link_button)

        # Affichez la fenêtre
        TPXO9_window.exec_()

    # ------------------------------------------------------------------#
    def select_tpxo_file(self):
        directory_path = QFileDialog.getExistingDirectory(self, "Select directory")

        if directory_path:
            self.TPXO_path = directory_path
            # Save the TPXO_path to QGIS settings
            settings = QgsSettings()
            settings.setValue("/TPXO_path", self.TPXO_path)
            # Set the label text to 'Loaded' and the color to green
            self.tpxoStatusLabel.setText(f"TPXO file loaded: {self.TPXO_path}")
            self.tpxoStatusLabel.setStyleSheet("color: green")
        else:
            # Set the label text to 'Not Loaded' and the color to orange
            self.tpxoStatusLabel.setText("TPXO File: Not Loaded")
            self.tpxoStatusLabel.setStyleSheet("color: orange")

    # ------------------------------------------------------------------#

    def create_ROMSnames_list(self):
        # Create a dictionary mapping harmonic names to their corresponding checkBoxes
        harmonics_checkBoxes = {
            'm2': self.m2checkBox,
            'n2': self.n2checkBox,
            'k2': self.k2checkBox,
            'k1': self.k1checkBox,
            'o1': self.o1checkBox,
            'p1': self.p1checkBox,
            'q1': self.q1checkBox,
            'mm': self.mmcheckBox,
            'mf': self.mfcheckBox,
            'm4': self.m4checkBox,
            'mn4': self.mn4checkBox,
            'ms4': self.ms4checkBox,
            's2': self.s2checkBox,
        }

        # Create a list to hold the names of selected harmonics
        self.ROMSnames = []

        # Iterate over the dictionary
        for harmonic, checkBox in harmonics_checkBoxes.items():
            # If the checkBox is checked, add the harmonic name to the list
            if checkBox.isChecked():
                self.ROMSnames.append(harmonic)
        print(self.ROMSnames)
        # Return the list of selected harmonics
        return self.ROMSnames
     # ------------------------------------------------------------------#
    def on_checkBox_state_changed(self):
        self.ROMSnames = self.create_ROMSnames_list()

     # ------------------------------------------------------------------#


    def on_execute_Tides(self):

        #Init date for tides
        self.date_min = self.datestart.date()
        # Get the year, month, and day from self.date_min
        year = self.date_min.year()
        month = self.date_min.month()
        day = self.date_min.day()
        # Use them to create a datetime object
        date_min_datetime = datetime(year, month, day)
        # Suppose self.date_min and self.date_max are set previously in your code
        date_min = self.datestart.date()
        date_max = self.dateend.date()
        # Calculate the number of days between self.date_min and self.date_max
        lengthSim = date_min.daysTo(date_max)
        harmoniques = self.ROMSnames
        croco_grd = self.grdname_full_path
        TPXO_path = self.TPXO_path
        grdname = self.gridnameLineEdit.text()
        make_tides_script(TPXO_path, croco_grd, harmoniques, lengthSim, date_min_datetime, grdname)





    ###############################################################################################
    #                                          BULK                                               #
    ###############################################################################################
    def open_era5_window(self):
        # Créez une nouvelle fenêtre de dialogue
        era5_window = QDialog(self)
        era5_window.setWindowTitle("ERA5 Window")

        # Créez un widget QLabel pour afficher le message en anglais
        message_label = QLabel(
            "To use the ERA5 model, you must first create your API file. All the information is available <a href='https://cds.climate.copernicus.eu/api-how-to'>HERE</a>.")
        message_label.setOpenExternalLinks(True)
        message_label.setAlignment(Qt.AlignCenter)

        # Créez un bouton pour ouvrir le lien
        link_button = QPushButton("Open Link")
        link_button.clicked.connect(self.open_era5_link)

        # Créez un layout vertical pour la fenêtre et ajoutez les widgets
        layout = QVBoxLayout(era5_window)
        layout.addWidget(message_label)
        layout.addWidget(link_button)

        # Affichez la fenêtre
        era5_window.exec_()

    # ------------------------------------------------------------------#

    def run_era5_script(self):
        directory = self.Environnement_2.text()
        title = self.gridprojecttitleLineEdit.text()
        grdname = self.gridnameLineEdit.text() + '.nc'
        lon_min = float(self.lon_min)
        lon_max = float(self.lon_max)
        lat_min = float(self.lat_min)
        lat_max = float(self.lat_max)
        Ymax = self.Ymax
        Ymin = self.Ymin
        Mmax = self.Mmax
        Mmin = self.Mmin

        ERA5_request_script(title, lon_min, lon_max, lat_min, lat_max, directory, Ymin, Ymax, Mmin, Mmax)

    ###############################################################################################
    #                                    Save Variable                                            #
    ###############################################################################################

    def save_variables_to_file(self):
        directory = self.Environnement_2.text()
        title = self.gridprojecttitleLineEdit.text()
        grdname = self.gridnameLineEdit.text()
        dl = self.dlDoubleSpin.text()
        topo = self.topodirLineEdit.text()
        lat_min = self.latminLineEdit.text()
        lat_max = self.latmaxLineEdit.text()
        lon_min = self.lonminLineEdit.text()
        lon_max = self.lonmaxLineEdit.text()

        if not self.titre:
            QMessageBox.warning(self, "Warning", "Il manque la variable: titre")
            return

        if not directory:
            QMessageBox.warning(self, "Warning", "Il manque la variable: environment_directory")
            return

        if not grdname:
            QMessageBox.warning(self, "Warning", "Il manque la variable: grdname")
            return

        ###############################################################################################
        #                                  Create SQL                                                 #
        ###############################################################################################

        # Create and configure the database
        db = QSqlDatabase.addDatabase('QSQLITE')
        db.setDatabaseName(self.db_path)

        if not db.open():
            QMessageBox.critical(self, "Database Error", db.lastError().text())
            return

        query = QSqlQuery()

        sql = """
                CREATE TABLE IF NOT EXISTS Grid (
                    title TEXT PRIMARY KEY,
                    directory TEXT,
                    grdname TEXT,
                    dl REAL,
                    topo TEXT,
                    lat_min REAL,
                    lat_max REAL,
                    lon_min REAL,
                    lon_max REAL
                )
                """

        if not query.exec_(sql):
            QMessageBox.critical(self, "Database Error", query.lastError().text())
            return

        sql = """
                INSERT OR REPLACE INTO Grid 
                (title, directory, grdname, dl, topo, lat_min, lat_max, lon_min, lon_max)
                VALUES 
                (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """

        query.prepare(sql)
        query.addBindValue(title)
        query.addBindValue(directory)
        query.addBindValue(grdname)
        query.addBindValue(dl)

        query.addBindValue(topo)
        query.addBindValue(lat_min)
        query.addBindValue(lat_max)
        query.addBindValue(lon_min)
        query.addBindValue(lon_max)

        if not query.exec_():
            QMessageBox.critical(self, "Database Error", query.lastError().text())
            return

        QMessageBox.information(self, "Information", "Variables saved to the file and database.")

    ######################
    # Grid.exe
    ######################

    def on_execute_grid(self):
        directory = self.Environnement_2.text()
        title = self.gridprojecttitleLineEdit.text()
        grdname = self.gridnameLineEdit.text() + '.nc'
        lon_min = float(self.lon_min)
        lon_max = float(self.lon_max)
        lat_min = float(self.lat_min)
        lat_max = float(self.lat_max)
        dl = float(self.dlDoubleSpin.text())
        topo = self.topodirLineEdit.text()

        self.grdname_full_path = make_grid_function(title, grdname, lon_min, lon_max, lat_min, lat_max, dl, topo, directory)
        print(self.grdname_full_path)

    ####################
    # Open project
    ##################
    def load_projects(self):
        # Execute a request for get all titles of projects pour obtenir tous les titres de projets
        query = QSqlQuery(self.db)
        query.exec_("SELECT title FROM Grid")

        # clear ComboBox
        self.opengridprojectComboBox.clear()
        self.opengridprojectComboBox.addItem("")

        # Add each title to the ComboBox
        while query.next():
            primary_key = query.value(0)
            self.opengridprojectComboBox.addItem(primary_key)

    def update_variables(self, index):
        # Get title of selected project
        selected_title = self.opengridprojectComboBox.itemText(index)

        # Execut requete for get variables of selected projet
        query = QSqlQuery(self.db)
        query.prepare("SELECT * FROM Grid WHERE title = :title")
        query.bindValue(":title", selected_title)
        query.exec_()

        if query.next():
            directory = query.value(1)
            grdname = query.value(2)
            dl = query.value(3)

            topo = query.value(5)
            lat_min = query.value(6)
            lat_max = query.value(7)
            lon_min = query.value(8)
            lon_max = query.value(9)

            # MAJ variables
            self.Environnement_2.setText(directory)
            self.gridprojecttitleLineEdit.setText(selected_title)
            self.gridnameLineEdit.setText(grdname)
            self.dlDoubleSpin.setValue(float(dl))

            self.topodirLineEdit.setText(topo)
            self.latminLineEdit.setText(str(lat_min))
            self.latmaxLineEdit.setText(str(lat_max))
            self.lonminLineEdit.setText(str(lon_min))
            self.lonmaxLineEdit.setText(str(lon_max))

