"""
/***************************************************************************
 qcrocoflow_croco_grid_dialog
                                 Aa QGIS plugin
 qcrocoflow_crocogrid
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-05-25
        git sha              : $Format:%H$
        copyright            : by Jonathan nejmann & Emmanuel Poizot
        emails               : jonathan.nejmann@hotmail.fr
                               emmanuel.poizot@lecnam.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import numpy as np
import datetime
import netCDF4 as nc
import os
from datetime import date , datetime
from PyQt5.QtWidgets import QMessageBox


class qcrocoflow_croco_TPXO():
    def __init__(self, _parent):
        self.parentApp = _parent
    @classmethod
    def TPXO2CROCO(self, t0, ROMSnames, crocoGRD, fnOut, ndays, TPXO_path, grdname):
        """
        Convert TPXO data to forcing Croco format.
            t0: Initial date for tide time, in MATLAB datenum format.
            ROMSnames: List of harmonic components.
            crocoGRD: Path to the ROMS grid file.
            fnOut: Path to the output file.
            ndays: Number of days for which data is to be extracted.
            TPXO_path: Path to the TPXO data directory.
        """

        # Convert the MATLAB date to a Python datetime object
        date_1968 = datetime(1968, 5, 23)
        datenum_1968 = date_1968.toordinal() + 366
        python_datetime = datetime.fromordinal(int(t0) - 366)
        ROMStitle = f'ROMS TPXO data for {python_datetime}'

        # Open the croco grid file and extract relevant variables
        with nc.Dataset(crocoGRD, 'r') as grid:
            lonR = np.mod(grid.variables['lon_rho'][:], 360)
            latR = grid.variables['lat_rho'][:]
            maskR = grid.variables['mask_rho'][:]
            maskP = grid.variables['mask_psi'][:]

        L, M = np.shape(maskP)

        # Define the dictionary for the TPXO data paths
        # Each harmonic component has a separate file for elevation and velocity data
        TPXOfile = {
            'grid': {
                'atlas30': os.path.join(TPXO_path, 'grid_tpxo9_atlas_30_v5.nc'),
            },
            'elev': {
                'k1': os.path.join(TPXO_path, 'hf.k1_tpxo9_atlas_30_v5.nc'),
                'k2': os.path.join(TPXO_path, 'hf.k2_tpxo9_atlas_30_v5.nc'),
                'm2': os.path.join(TPXO_path, 'hf.m2_tpxo9_atlas_30_v5.nc'),
                'm4': os.path.join(TPXO_path, 'hf.m4_tpxo9_atlas_30_v5.nc'),
                'mf': os.path.join(TPXO_path, 'hf.mf_tpxo9_atlas_30_v5.nc'),
                'mm': os.path.join(TPXO_path, 'hf.mm_tpxo9_atlas_30_v5.nc'),
                'mn4': os.path.join(TPXO_path, 'hf.mn4_tpxo9_atlas_30_v5.nc'),
                'ms4': os.path.join(TPXO_path, 'hf.ms4_tpxo9_atlas_30_v5.nc'),
                'n2': os.path.join(TPXO_path, 'hf.n2_tpxo9_atlas_30_v5.nc'),
                'o1': os.path.join(TPXO_path, 'hf.o1_tpxo9_atlas_30_v5.nc'),
                'p1': os.path.join(TPXO_path, 'hf.p1_tpxo9_atlas_30_v5.nc'),
                'q1': os.path.join(TPXO_path, 'hf.q1_tpxo9_atlas_30_v5.nc'),
                's2': os.path.join(TPXO_path, 'hf.s2_tpxo9_atlas_30_v5.nc'),
            },
            'vel': {
                'k1': os.path.join(TPXO_path, 'uv.k1_tpxo9_atlas_30_v5.nc'),
                'k2': os.path.join(TPXO_path, 'uv.k2_tpxo9_atlas_30_v5.nc'),
                'm2': os.path.join(TPXO_path, 'uv.m2_tpxo9_atlas_30_v5.nc'),
                'm4': os.path.join(TPXO_path, 'uv.m4_tpxo9_atlas_30_v5.nc'),
                'mf': os.path.join(TPXO_path, 'uv.mf_tpxo9_atlas_30_v5.nc'),
                'mm': os.path.join(TPXO_path, 'uv.mm_tpxo9_atlas_30_v5.nc'),
                'mn4': os.path.join(TPXO_path, 'uv.mn4_tpxo9_atlas_30_v5.nc'),
                'ms4': os.path.join(TPXO_path, 'uv.ms4_tpxo9_atlas_30_v5.nc'),
                'n2': os.path.join(TPXO_path, 'uv.n2_tpxo9_atlas_30_v5.nc'),
                'o1': os.path.join(TPXO_path, 'uv.o1_tpxo9_atlas_30_v5.nc'),
                'p1': os.path.join(TPXO_path, 'uv.p1_tpxo9_atlas_30_v5.nc'),
                'q1': os.path.join(TPXO_path, 'uv.q1_tpxo9_atlas_30_v5.nc'),
                's2': os.path.join(TPXO_path, 'uv.s2_tpxo9_atlas_30_v5.nc'),
            }
        }

        print('Reading TPXO')
        TPXO = self.readTPXOdata(TPXOfile, ROMSnames, lonR, latR)

        # Define the dictionary for the TPXO harmonics metadata
        # Each harmonic has a set of Doodson numbers, reference phase, and speed
        TPXOharmonics = {
            'mm': [0, 1, 0, -1, 0, 0, 0, 0.5443747],
            'mf': [0, 2, 0, 0, 0, 0, 0, 1.0980331],
            'q1': [1, -3, 1, 1, 0, 0, 270, 13.3986607],
            'o1': [1, -2, 1, 0, 0, 0, 270, 13.9430351],
            'p1': [1, 0, -1, 0, 0, 0, 270, 14.9589310],
            'k1': [1, 0, 1, 0, 0, 0, 90, 15.0410690],
            'n2': [2, -3, 2, 1, 0, 0, 0, 28.4397297],
            'm2': [2, -2, 2, 0, 0, 0, 0, 28.9841042],
            's2': [2, 0, 0, 0, 0, 0, 0, 30.0000000],
            'k2': [2, 0, 2, 0, 0, 0, 0, 30.0821381],
            'mn4': [4, -5, 4, 1, 0, 0, 0, 57.4238319],
            'm4': [4, -4, 4, 0, 0, 0, 0, 57.9682083],
            'ms4': [4, -2, 2, 0, 0, 0, 0, 58.9841042],
        }



        # Initialize dictionaries and lists to store harmonic information
        ROMSharmonics = {}
        Vdeg = {}
        Nharmonics = len(ROMSnames)
        ROMSperiods = [0] * Nharmonics
        for n in range(Nharmonics):
            ROMSharmonics[ROMSnames[n]] = TPXOharmonics[ROMSnames[n]]
            ROMSperiods[n] = 360 / TPXOharmonics[ROMSnames[n]][-1]

            Vdeg[ROMSnames[n]] = self.Vphase(t0, ROMSharmonics[ROMSnames[n]])

        # Compute the nodal corrections for the chosen date
        fFac, uFac = self.TPXOnodalfactors(t0 + ndays / 2, ROMSnames)

        # Initialize arrays to store TPXO data
        zamp, zpha, uamp, upha, vamp, vpha, major, eccentricity, inclination, phase = (
            np.zeros((L + 1, M + 1, Nharmonics)).transpose(1, 0, 2) for _ in range(10)
        )

        # Loop over each harmonic and interpolate the TPXO data onto the ROMS grid
        count_a30 = -1
        for k, name in enumerate(ROMSnames):
            count_a30 += 1


            harmonic = TPXO['harmonic_a30'][count_a30]['harmonic']
            print(f'Interpolating {harmonic} amplitudes')

            ei = self.interpTPXO(TPXO['h'], count_a30, lonR, latR, maskR)
            zamp[:, :, k] = np.abs(ei) * fFac[name]
            zpha[:, :, k] = np.mod(-np.angle(ei) * 180 / np.pi - uFac[name] - Vdeg[name], 360)

            print(f'Interpolating {harmonic} U')
            ei = self.interpTPXO(TPXO['U'], count_a30, lonR, latR, maskR)
            uamp[:, :, k] = np.abs(ei) * fFac[name]
            upha[:, :, k] = np.mod(-np.angle(ei) * 180 / np.pi - uFac[name] - Vdeg[name], 360)

            print(f'Interpolating {harmonic} V')
            ei = self.interpTPXO(TPXO['V'], count_a30, lonR, latR, maskR)
            vamp[:, :, k] = np.abs(ei) * fFac[name]
            vpha[:, :, k] = np.mod(-np.angle(ei) * 180 / np.pi - uFac[name] - Vdeg[name], 360)

            maj, ecc, inc, pha = self.ap2ep(np.squeeze(uamp[:, :, k]), np.squeeze(upha[:, :, k]), np.squeeze(vamp[:, :, k]),
                                       np.squeeze(vpha[:, :, k]))
            ecc[np.isnan(ecc)] = 0
            major[:, :, k] = maj
            eccentricity[:, :, k] = ecc
            inclination[:, :, k] = inc
            phase[:, :, k] = pha

        # Compute the minor axis from the major axis and eccentricity
        minor = major * eccentricity


        # Set up output netCDF forcing file
        print('Creating netcdf file')

        # global attributes
        varname = ['tide_period', 'tide_Ephase', 'tide_Eamp', 'tide_Cmin', 'tide_Cmax',
                   'tide_Cangle', 'tide_Cphase', 'tide_Uamp', 'tide_Uphase',
                   'tide_Vamp', 'tide_Vphase']
        vartype = ['f8'] * len(varname)
        vardims = [('tide_period',)] + [('tide_period','eta_rho', 'xi_rho')] * 10
        nVar = len(varname)

        # Create netCDF4 Dataset
        ds = nc.Dataset(fnOut, 'w', format='NETCDF4')

        # Define dimensions
        ds.createDimension('tide_period', Nharmonics)
        ds.createDimension('xi_rho', M + 1)
        ds.createDimension('eta_rho', L + 1)

        # Define variables
        for i in range(nVar):
            ds.createVariable(varname[i], vartype[i], vardims[i])

        ROMSnames_att = " ".join(ROMSnames)
        today = date.today().strftime("%Y%m%d")

        ds.title = ROMStitle
        ds.Creation_date = today
        ds.grd_file = crocoGRD
        ds.type = 'ROMS forcing file from TPXO'
        ds.ini_date_datenumber = t0
        ds.ini_date_mjd = (t0 - datenum_1968)
        ds.components = ROMSnames_att

        # Assign attributes to each variable
        attnames = [['long_name', 'units']] * nVar
        attvals = [['Tide angular period', 'hours'],
                   ['Tide elevation phase angle', 'degrees'],
                   ['Tide elevation amplitude', 'meters'],
                   ['Tidal current ellipse semi-minor axis', 'meter second-1'],
                   ['Tidal current ellipse semi-major axis', 'meter second-1'],
                   ['Tidal current ellipse inclination angle', 'degrees between semi-major axis and east'],
                   ['Tidal current phase angle', 'degrees'],
                   ['Tidal current U-component amplitude', 'meters'],
                   ['Tidal current U-component phase', 'degrees'],
                   ['Tidal current V-component amplitude', 'meters'],
                   ['Tidal current V-component phase', 'degrees']]

        for n in range(nVar):
            for i in range(len(attnames[n])):
                ds[varname[n]].setncattr(attnames[n][i], attvals[n][i])

        # Write data to the output file
        # We transpose our data arrays to match the dimensions in our netCDF dataset
        ds['tide_period'][:] = ROMSperiods
        ds['tide_Eamp'][:] = np.transpose(zamp, (2, 1, 0))
        ds['tide_Ephase'][:] = np.transpose(zpha, (2, 1, 0))
        ds['tide_Cmax'][:] = np.transpose(major, (2, 1, 0))
        ds['tide_Cmin'][:] = np.transpose(minor, (2, 1, 0))
        ds['tide_Cangle'][:] = np.transpose(inclination, (2, 1, 0))
        ds['tide_Cphase'][:] = np.transpose(phase, (2, 1, 0))
        ds['tide_Uamp'][:] = np.transpose(uamp, (2, 1, 0))
        ds['tide_Uphase'][:] = np.transpose(upha, (2, 1, 0))
        ds['tide_Vamp'][:] = np.transpose(vamp, (2, 1, 0))
        ds['tide_Vphase'][:] = np.transpose(vpha, (2, 1, 0))

        # Close the netCDF dataset
        ds.close()

        QMessageBox.information(self.parentApp, "Interpolation Completed", f"Interpolation completed, the forcing file was successfully generated with the name {grdname}_tides.nc")

    def ap2ep(self, Au, PHIu, Av, PHIv):
        """
        This function converts amplitude and phase tidal constituents into ellipse parameters.

        Parameters:
        Au (numpy.array): amplitude of u-component
        PHIu (numpy.array): phase of u-component
        Av (numpy.array): amplitude of v-component
        PHIv (numpy.array): phase of v-component

        Returns:
        SEMA (numpy.array): Semi-major axis of the ellipse
        ECC (numpy.array): ECC of the ellipse
        INC (numpy.array): INC of the ellipse
        PHA (numpy.array): Phase angle of the ellipse
        """
        # Convert the phases from degrees to radians
        PHIu = np.deg2rad(PHIu)
        PHIv = np.deg2rad(PHIv)

        # Calculate the complex amplitudes for u and v
        i = complex(0, 1)
        u = Au * np.exp(-i * PHIu)
        v = Av * np.exp(-i * PHIv)

        # Compute the counterclockwise and clockwise circles
        wp = (u + i * v) / 2
        wm = np.conj(u - i * v) / 2

        # Calculate the amplitudes and angles
        Wp = np.abs(wp)
        Wm = np.abs(wm)
        THETAp = np.angle(wp)
        THETAm = np.angle(wm)

        # Compute the ellipse parameters
        SEMA = Wp + Wm  # Semi-major axis
        SEMI = Wp - Wm  # Semi-minor axis
        ECC = np.where(SEMA != 0, SEMI / SEMA, 0)  # ECC
        PHA = (THETAm - THETAp) / 2  # Phase angle
        INC = (THETAm + THETAp) / 2  # INC

        # Convert back from radians to degrees
        PHA = np.rad2deg(PHA)
        INC = np.rad2deg(INC)

        # Adjust phase and INC angles to range [0, 2*pi)
        PHA[PHA < 0] += 360
        INC[INC < 0] += 360

        print('hello')
        return SEMA, ECC, INC, PHA

    def interpTPXO(self, TPXOvar, count, lon, lat, mask):
        """
        This function extracts TPXO data and interpolates it onto CROCO grid.
        Inputs:
            - TPXOvar: hRE, hIm, uRE, uIm, vRe, or vIm
            - count:
            - lon, lat: 2D arrays of longitude and latitude to interpolate to
            - mask: array of 1s and 0s corresponding to wet and dry points of lon & lat
        Output:
            - VARinterp (VAR on lon, lat grid)
        """

        # Initialize the interpolated variable as a complex array of zeros
        VARinterp = np.zeros(mask.shape, dtype=np.complex128)
        iswet = mask == 1  # Array of booleans where the mask is 1 (wet points)

        # Extract coordinates and variable values from TPXO data
        x = TPXOvar['x_a30']
        y = TPXOvar['y_a30']
        z = np.squeeze(TPXOvar['z_a30'][:, :, count])
        depth_masked = TPXOvar['depth_a30']
        depth = depth_masked.filled()  # Convert the MaskedArray to an ndarray, filling masked values with a default fill value

        m = np.logical_and(TPXOvar['mask_a30'],
                           depth > 0)  # Logical mask where depth is above 0 and TPXOvar mask is true

        # Interpolate z using nearest griddata method
        z = griddata((x[m], y[m]), z[m], (x, y), method='nearest')

        # TODO: debug
        points = np.array([x, y])

        # Création de la grille d'interpolation
        F = griddata((x.flatten(), y.flatten()), z.flatten(), (lon[iswet].T, lat[iswet].T), method='linear')

        # Assignation des valeurs interpolées aux positions correspondantes dans VARinterp
        VARinterp[iswet] = F
        VARinterp = VARinterp.transpose()

        return VARinterp

    def readTPXOdata(self, TPXOfile, ROMSnames, lon, lat):
        """
        This function reads tidal data from the TPXO model and extracts relevant data based on provided ROMS names.

        Parameters:
        TPXOfile (dict): dictionary with TPXO data files (grids and data)
        ROMSnames (list): list of names of ROMS tidal constituents to be extracted
        lon (numpy.array): longitudes of the area of interest
        lat (numpy.array): latitudes of the area of interest

        Returns:
        TPXO (dict): dictionary with extracted data from TPXO model
        """
        # Calculate the min and max bounds for given longitudes and latitudes
        lonmin, lonmax = np.min(lon), np.max(lon)
        latmin, latmax = np.min(lat), np.max(lat)
        # Create bounds for the longitude and latitude
        bndx = [lon[0, 0], lon[-1, 0], lon[-1, -1], lon[0, -1]]
        bndy = [lat[0, 0], lat[-1, 0], lat[-1, -1], lat[0, -1]]
        # Variables to extract from the TPXO file
        variables = ['h', 'U', 'V']
        # Initialize the counter for 'atlas30' grids
        count_atlas30 = -1

        # Initialize the TPXO dictionary to store all data
        TPXO = {var: {'x_a30': None, 'y_a30': None, 'depth_a30': None, 'mask_a30': None, 'z_a30': None} for var in
                variables}
        TPXO['harmonic_a30'] = []

        for harmonic in ROMSnames:
            TPXOfile_grid = TPXOfile['grid']['atlas30']
            count_atlas30 += 1
            TPXO['harmonic_a30'].append({'harmonic': harmonic})

            # Access elevation and velocity data for the current ROMS name
            TPXOfile_elev = TPXOfile['elev'][harmonic.lower()]
            TPXOfile_vel = TPXOfile['vel'][harmonic.lower()]
            files = [TPXOfile_elev, TPXOfile_vel, TPXOfile_vel]

            for i, variable in enumerate(variables):
                coordinate = 'z' if variable == 'h' else variable.lower()
                # Open the data file and extract longitude and latitude data
                data = Dataset(files[i], 'r')
                X1 = data['lon_' + coordinate][:]
                Y1 = data['lat_' + coordinate][:]
                # Create a grid from longitudes and latitudes
                X, Y = np.meshgrid(X1, Y1)

                # Open the TPXO grid file and extract depth data
                with Dataset(TPXOfile_grid, 'r') as nc_file:
                    H = nc_file.variables['h' + coordinate][:]
                    H = np.transpose(H)

                # Read real and imaginary parts of the variables
                Re_part = np.array(Dataset(files[i], 'r').variables[variable.lower() + 'Re'][:])
                Im_part = np.array(Dataset(files[i], 'r').variables[variable.lower() + 'Im'][:])

                # Create a complex number from the real and imaginary parts
                H_complex = Re_part + 1j * Im_part
                # Transpose the H_complex matrix to match X and Y dimensions
                H_complex = np.transpose(H_complex)

                # Get the indices of cells that are inside the bounds defined earlier
                I, J = np.where((Y >= latmin) & (Y <= latmax) & (X >= lonmin) & (X <= lonmax))

                # Remove duplicate indices
                I, J = np.unique(I), np.unique(J)

                # Create subsets of X, Y and H_complex using found indices
                x = X[I][:, J]
                y = Y[I][:, J]
                z = H_complex[I][:, J] * (0.001 if variable == 'h' else 0.0001)

                # Compute depth
                depth = (H[I][:, J]).T
                depth = np.transpose(depth)

                # Create a mask for points that are inside the bounds defined
                polygon = Path(np.column_stack((bndx, bndy)))
                mask = polygon.contains_points(np.column_stack((x.ravel(), y.ravel()))).reshape(x.shape)

                # Assigning the computed data to the TPXO dictionary
                TPXO[variable]['x_a30'] = x
                TPXO[variable]['y_a30'] = y
                TPXO[variable]['depth_a30'] = depth
                TPXO[variable]['mask_a30'] = mask

                # Initialize the H_complex array in the TPXO dictionary if it is None
                if TPXO[variable]['z_a30'] is None:
                    TPXO[variable]['z_a30'] = np.empty((mask.shape[0], mask.shape[1], len(ROMSnames)), dtype=complex)

                # Assign the computed H_complex to the TPXO dictionary

                if variable == 'h':
                    TPXO[variable]['z_a30'][:, :, count_atlas30] = z
                else:
                    TPXO[variable]['z_a30'][:, :, count_atlas30] = z / np.tile(TPXO[variable]['depth_a30'], (1, 1, 1))

        # Return the dictionary with all the data
        return TPXO

    def compute_factors(self, t):
        """
        function to compute different factors for f and u.
        """
        VN = np.mod(360 * (0.719954 - 5.372617 * t + 0.000006 * t * t), 360)
        if VN < 0:
            VN += 360
        VN = VN * np.pi / 180

        cN = np.cos(VN)
        c2N = np.cos(2 * VN)
        c3N = np.cos(3 * VN)
        sN = np.sin(VN)
        s2N = np.sin(2 * VN)
        s3N = np.sin(3 * VN)

        return cN, c2N, c3N, sN, s2N, s3N


    def TPXOnodalfactors(self, dnum, names):
        """
        Computes f and u factors for the harmonics listed in cell array names.
        Only those which are in the TPXO model are evaluated.
        They are evaluated at time dnum.
        """

        f = dict()
        u = dict()
        f_factors = dict()
        u_factors = dict()
        days_until_1900 = ((datetime(1900, 1, 1) - datetime(1, 1, 1)).days + 367)

        t = ((dnum + 0.5) - days_until_1900) / 36525

        cN, c2N, c3N, sN, s2N, s3N = self.compute_factors(t)

        f["mm"] = 1.0 - 0.1300 * cN + 0.0013 * c2N
        u["mm"] = 0
        f["mf"] = 1.0429 + 0.4135 * cN - 0.004 * c2N
        u["mf"] = -0.4143 * sN + 0.0468 * s2N - 0.0066 * s3N
        f["o1"] = 1.0089 + .1871 * cN - 0.0147 * c2N + 0.0014 * c3N
        u["o1"] = 0.1885 * sN - 0.0234 * s2N + 0.0033 * s3N
        f["k1"] = 1.0060 + 0.1150 * cN - 0.0088 * c2N + 0.0006 * c3N
        u["k1"] = -0.1546 * sN + 0.0119 * s2N - 0.0012 * s3N
        f["m2"] = 1.0004 - 0.0373 * cN + 0.0002 * c2N
        u["m2"] = -0.0374 * sN
        f["k2"] = 1.0241 + 0.2863 * cN + 0.0083 * c2N - 0.0015 * c3N
        u["k2"] = -0.3096 * sN + 0.0119 * s2N - 0.0007 * s3N

        f["q1"] = f["o1"]
        u["q1"] = u["o1"]
        f["n2"] = f["m2"]
        u["n2"] = u["m2"]
        f["mn4"] = f["m2"] ** 2
        u["mn4"] = 2 * u["m2"]
        f["m4"] = f["m2"] ** 2
        u["m4"] = 2 * u["m2"]
        f["ms4"] = f["m2"]
        u["ms4"] = u["m2"]

        # Assign f and u factors for each harmonic name
        for n in names:
            if n in f:
                f_factors[n] = f[n]
                u_factors[n] = np.mod(u[n] * 180.0 / np.pi, 360.0)
            else:
                f_factors[n] = 1
                u_factors[n] = 0

        return f_factors, u_factors

    def compute_phase(self, t, DN_Nbr, DN_Pha, DN_Spd, tHour):
        """
        Helper function to compute phase factors.
        """

        Vs = np.mod(360 * (0.751206 + 1336.855231 * t - 0.000003 * t ** 2), 360)
        Vh = np.mod(360 * (0.776935 + 100.002136 * t + 0.000001 * t * t), 360)
        Vp = np.mod(360 * (0.928693 + 11.302872 * t - 0.000029 * t * t), 360)
        VN = np.mod(360 * (0.719954 - 5.372617 * t + 0.000006 * t * t), 360)
        Vp1 = np.mod(360 * (0.781169 + 0.004775 * t + 0.000001 * t * t), 360)

        for V in [Vs, Vh, Vp, VN, Vp1]:
            if V < 0:
                V += 360

        Vdeg = tHour * DN_Spd + np.dot(Vs, DN_Nbr[1]) + np.dot(Vh, DN_Nbr[2]) + \
               np.dot(Vp, DN_Nbr[3]) + np.dot(VN, DN_Nbr[4]) + np.dot(Vp1, DN_Nbr[5]) + DN_Pha

        Vdeg = np.mod(Vdeg, 360)

        return Vdeg

    def Vphase(self, dnum, DN_List):
        """
        Computes equilibrium phases in accordance with Cartwright "tidal analysis - a retrospect".
        """

        days_until_1900 = (datetime(1900, 1, 1) - datetime(1, 1, 1)).days + 367

        t = (dnum + 0.5 - days_until_1900) / 36525

        tHour = np.mod(dnum, 1) * 24
        DN_Nbr = DN_List[:7]
        DN_Pha = DN_List[6]
        DN_Spd = DN_List[7]

        Vdeg = self.compute_phase(t, DN_Nbr, DN_Pha, DN_Spd, tHour)

        print(Vdeg)
        return Vdeg
