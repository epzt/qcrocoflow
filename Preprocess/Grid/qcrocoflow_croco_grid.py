"""
/***************************************************************************
 qcrocoflow_croco_grid_dialog
                                 Aa QGIS plugin
 qcrocoflow_crocogrid
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-05-25
        git sha              : $Format:%H$
        copyright            : by Jonathan nejmann & Emmanuel Poizot
        emails               : jonathan.nejmann@hotmail.fr
                               emmanuel.poizot@lecnam.net
 ***************************************************************************/
This module provides a function to create a regular grid from the coordinates
minimum and maximum latitude and longitude provided.
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# Python built-in modules
import os
# Third-party libraries
import numpy as np
import matplotlib.pyplot as plt
import netCDF4 as nc_module
from netCDF4 import Dataset
from qgis.core import (QgsCoordinateReferenceSystem, QgsFeature, QgsGeometry,
                       QgsMapLayer, QgsPointXY, QgsProject, QgsRectangle,
                       QgsVectorLayer, QgsRasterLayer, QgsCoordinateTransform)
# Local application/library specific imports
from .qcrocoflow_bathy_view import qcrocoflow_bathy_view
from ...qcrocoflow_croco_tools import qcrocoflow_crocotools_netCDFtoRaster

class qcrocoflow_croco_grid():

    def __init__(self, _parent=None):
        self.parentAPP = _parent

    @classmethod
    def make_grid_function(self, title, grdname, lon_min, lon_max, lat_min, lat_max, dl, topofile, directory):
        """
            Creates a regular grid from latitude and longitude coordinates
            minimum and maximum provided.

            Parameters:
            title (str): The title of the output file.
            grdname (str): The name of the output file.
            lon_min (float): The minimum longitude of the area of interest.
            lon_max (float): The maximum longitude of the area of interest.
            lat_min (float): The minimum latitude of the area of interest.
            lat_max (float): The maximum latitude of the area of interest.
            dl (float): The interval of latitude and longitude coordinates.
            topofile (str): The path to the topographic file to use for the interpolation.
            directory (str): The directory where the output file will be saved.

            Returns:
            grdname_full_path
            """

        # Create longitude and latitude grids with dl resolution.
        x = np.arange(lon_min, lon_max, dl)
        y = np.arange(lat_min, lat_max, dl)

        # Initialize the coordinate transformation from EPSG:3857 to EPSG:4326.
        transform_4326 = QgsCoordinateTransform(QgsCoordinateReferenceSystem('EPSG:3857'),
                                                QgsCoordinateReferenceSystem('EPSG:4326'),
                                                QgsProject.instance())

        # Create 2D longitude and latitude grids.
        Lonr, Latr = np.meshgrid(x, y)

        # Transform each grid point to EPSG:4326.
        for i in range(Lonr.shape[0]):
            for j in range(Lonr.shape[1]):
                point_4326 = transform_4326.transform(QgsPointXY(Lonr[i, j], Latr[i, j]))
                Lonr[i, j] = point_4326.x()
                Latr[i, j] = point_4326.y()

        # Initialize new variables.
        dndx = np.zeros(Latr.shape)
        dmde = np.zeros(Latr.shape)
        pn = np.full_like(Latr, 1/dl)
        pm = np.full_like(Latr, 1/dl)

        # Convert longitude and latitude grids from rho to u, v and p.
        Lonu, Lonv, Lonp = self.rho2uvp(Lonr)
        Latu, Latv, Latp = self.rho2uvp(Latr)

        # Get grid dimensions.
        M, L = Latp.shape

        # Create output NC with specified name and directory.
        grdname_full_path = self.create_grid_file(L, M, grdname, title, directory)

        # Open netCDF file for writing.
        with nc_module.Dataset(grdname_full_path, 'a') as nc:
            # Assign computed grids to corresponding variables in netCDF file.
                nc['lat_u'][:] = Latu
                nc['lon_u'][:] = Lonu
                nc['lat_v'][:] = Latv
                nc['lon_v'][:] = Lonv
                nc['lat_rho'][:] = Latr
                nc['lon_rho'][:] = Lonr
                nc['lat_psi'][:] = Latp
                nc['lon_psi'][:] = Lonp

        # Initialize matrices for x and y coordinates on the rho grid.
        xr,yr = self.get_rho(dl)

        # Convert coordinate grids from rho to u, v and p.
        xu, xv, xp = self.rho2uvp(xr)
        yu, yv, yp = self.rho2uvp(yr)

        # Calculate the angle.
        angle = self.get_angle_file(Latu, Lonu)

        # Compute the Coriolis parameter.
        f = 4 * np.pi * np.sin(np.pi * Latr / 180) * 366.25 / (24 * 3600 * 365.25)

        # Fill the grid file with the calculated parameters.
        print('Fill the grid file...')
        with Dataset(grdname_full_path, 'a') as nc:
            nc.variables['pm'][:] = pm
            nc.variables['pn'][:] = pn
            nc.variables['dndx'][:] = dndx
            nc.variables['dmde'][:] = dmde
            nc.variables['x_u'][:] = xu
            nc.variables['y_u'][:] = yu
            nc.variables['x_v'][:] = xv
            nc.variables['y_v'][:] = yv
            nc.variables['x_rho'][:] = xr
            nc.variables['y_rho'][:] = yr
            nc.variables['x_psi'][:] = xp
            nc.variables['y_psi'][:] = yp
            nc.variables['f'][:] = f
            nc.variables['angle'][:] = angle

            ######################################
            # Adding topography to the grid      #
            ######################################
            # Identifying the file extension of the topography file
            _, file_extension = os.path.splitext(topofile)
            file_extension = file_extension.lower()
            print(f"The file extension is: {file_extension}")

            # Choosing the topography adding method based on the file extension
            if file_extension == '.nc':
                h = self.add_topo_from_netcdf_file(grdname_full_path, topofile)
            elif file_extension in ['.grd', '.tif']:
                h = self.add_topo_from_raster_file(topofile, x.shape, y.shape)
            else:
                raise ValueError(f"Unsupported file type: {file_extension}")

            #####################################################################
            # Opening the graphical interface to visualize the bathymetry       #
            #####################################################################
            bathy_view = qcrocoflow_bathy_view()
            bathy_view.set_h(h, nc)
            bathy_view.exec_()

            # Retrieve the new depth level
            new_h = bathy_view.save_new_level()

            # Defining the mask based on the depth
            maskr = new_h > 0 if new_h is not None else h > 0

            # Visualizing the mask before processing
            mappable = plt.imshow(maskr, origin='lower', cmap='binary')
            plt.title('Mask before processing')
            plt.colorbar(mappable)
            plt.show()

            # Converting the rho mask to u, v, and p
            masku, maskv, maskp = self.uvp_mask_file(maskr)

            # Adding the masks to the netCDF file
            with nc_module.Dataset(grdname_full_path, 'a') as nc:
                nc.variables['mask_u'][:] = masku
                nc.variables['mask_v'][:] = maskv
                nc.variables['mask_psi'][:] = maskp
                nc.variables['mask_rho'][:] = maskr

                # Extracting latitude, longitude and "h" data
                lon = nc.variables['lon_rho'][:]
                lat = nc.variables['lat_rho'][:]
                h = nc.variables['h'][:]

            # Name of the GeoTIFF file to create
            tif_filename = "grid.tif"

            # Create an instance of qcrocoflow_crocotools_netCDFtoRaster
            nc2r = qcrocoflow_crocotools_netCDFtoRaster(QgsCoordinateReferenceSystem(4326))  # Use EPSG:4326 for CRS

            # Create a GeoTIFF file for "h" variable
            nc2r.createRaster(lon, lat, h, tif_filename, h.ndim)

            # Add the GeoTIFF file to the QGIS project
            raster_layer = QgsRasterLayer(tif_filename, "grid_show")

            if not raster_layer.isValid():
                print("Failed to load the layer!")
            else:
                # Add the layer to your QGIS project
                QgsProject.instance().addMapLayer(raster_layer)

            return grdname_full_path

    def add_topo_from_netcdf_file(self, grdname, topofile):
        """
        This function interpolates the topography data into the CROCO grid.

        Parameters:
        grdname: str
            Name of the CROCO grid file.
        topofile: str
            Name of the topography file.

        Returns:
        h: ndarray
            Interpolated topography data.
        """

        # Load CROCO grid
        try:
            grd = Dataset(grdname, 'r')
        except FileNotFoundError:
            print(f"File {grdname} not found.")
            return None

        lon_rho = grd.variables['lon_rho'][:]
        lat_rho = grd.variables['lat_rho'][:]
        pm = grd.variables['pm'][:]
        pn = grd.variables['pn'][:]
        grd.close()

        # Compute the average resolution of the CROCO grid
        dx = np.mean(1 / pm)
        dy = np.mean(1 / pn)
        dx_croco = np.mean([dx, dy])

        # Define the bounding box for subsetting TOPO data
        dl = max([1, 2 * (dx_croco / (60 * 1852))])  # estimate the required padding
        bbox = [np.min(lon_rho) - dl, np.max(lon_rho) + dl, np.min(lat_rho) - dl, np.max(lat_rho) + dl]

        # Load TOPO file
        try:
            nc = Dataset(topofile, 'r')
        except FileNotFoundError:
            print(f"File {topofile} not found.")
            return None

        lon_topo = nc.variables['lon'][:]
        lat_topo = nc.variables['lat'][:]

        # Subset the TOPO data based on the bounding box
        # The longitude is adjusted to the [-180, 180] range
        lon_topo_subset = lon_topo[np.logical_and(lon_topo >= bbox[0], lon_topo <= bbox[1])]
        lat_topo_subset = lat_topo[np.logical_and(lat_topo >= bbox[2], lat_topo <= bbox[3])]

        # Retrieve the topo data corresponding to the subset
        topo_subset = -nc.variables['topo'][np.ix_(lat_topo_subset, lon_topo_subset)]
        nc.close()

        # Rescale the resolution of the topo subset data
        dx_topo = compute_avg_resolution(lon_topo_subset, lat_topo_subset)
        while dx_croco > dx_topo:
            lon_topo_subset, lat_topo_subset, topo_subset = downscale_resolution(lon_topo_subset, lat_topo_subset,
                                                                                 topo_subset)
            dx_topo = compute_avg_resolution(lon_topo_subset, lat_topo_subset)

        # Interpolate the topo data into the CROCO grid using cubic interpolation
        h = griddata((lon_topo_subset.ravel(), lat_topo_subset.ravel()), topo_subset.ravel(), (lon_rho, lat_rho),
                     method='cubic')

        return h

    def compute_avg_resolution(self, lon, lat):
        """
        Compute the average resolution of the grid defined by lon and lat.

        Parameters:
        lon: ndarray
            Longitudes.
        lat: ndarray
            Latitudes.

        Returns:
        dx_avg: float
            Average resolution.
        """
        R = 6367442.76  # Earth radius in meters
        deg2rad = np.pi / 180
        dx = R * deg2rad * np.diff(lon) * np.cos(deg2rad * lat[:-1])
        dy = R * deg2rad * np.diff(lat)
        dx_avg = np.mean(np.hypot(dx, dy))

        return dx_avg

    def downscale_resolution(self, lon, lat, data):
        """
        Downscale the resolution of the data by a factor of 2.

        Parameters:
        lon: ndarray
            Longitudes.
        lat: ndarray
            Latitudes.
        data: ndarray
            Data.

        Returns:
        lon: ndarray
            Downscaled longitudes.
        lat: ndarray
            Downscaled latitudes.
        data: ndarray
            Downscaled data.
        """
        lon = 0.5 * (lon[1:] + lon[:-1])
        lon = lon[::2]
        lat = 0.5 * (lat[1:] + lat[:-1])
        lat = lat[::2]
        data = 0.25 * (data[1:, :-1] + data[1:, 1:] + data[:-1, :-1] + data[:-1, 1:])
        data = data[::2, ::2]

        return lon, lat, data

    def add_topo_from_raster_file(self, topofile, numColumns, numLines):
        """
        This function interpolates the topography data into the CROCO grid.

        Args:
            topofile (str): topography file.
            numColumns (int): x.shape.
            numLines (int): y.shape.

        Returns:
            h (np.array): Array with the reshaped topography data.
        """

        # Get raster and grid layers from the project
        basename = os.path.basename(topofile)
        raster_layer = QgsProject.instance().mapLayersByName(basename)[0]
        grid_layer = QgsProject.instance().mapLayersByName('grid')[0]

        # Reproject grid layer to WGS84
        crs_wgs84 = QgsCoordinateReferenceSystem("EPSG:4326")
        parameters = {'INPUT': grid_layer, 'TARGET_CRS': crs_wgs84, 'OUTPUT': 'memory:'}
        result = processing.run('native:reprojectlayer', parameters)

        # Check if the re-projection was successful
        if 'OUTPUT' not in result:
            raise Exception('Grid layer re-projection failed')

        grid_layer = result['OUTPUT']

        # Calculate zonal statistics
        zoneStat = QgsZonalStatistics(grid_layer, raster_layer, '', 1, QgsZonalStatistics.Mean)
        zoneStat.calculateStatistics(None)

        grid_layer.startEditing()

        # Rename the 'mean' field to 'topo'
        for field in grid_layer.fields():
            if field.name() == 'mean':
                grid_layer.renameAttribute(grid_layer.fields().indexFromName('mean'), 'topo')

        # Get the field indices
        field_index_x = grid_layer.fields().indexFromName("lower_left_x")
        field_index_y = grid_layer.fields().indexFromName("lower_left_y")
        field_index_topo = grid_layer.fields().indexFromName("topo")

        # Initialize numpy arrays
        features_count = grid_layer.featureCount()
        lat_rho, lon_rho, topo = np.zeros(features_count), np.zeros(features_count), np.zeros(features_count)

        # Update the fields with the coordinates and topography values
        for i, feature in enumerate(grid_layer.getFeatures()):
            bbox = feature.geometry().boundingBox()
            lower_left_x, lower_left_y = bbox.xMinimum(), bbox.yMinimum()

            topo[i] = 100 if feature['topo'] is None else feature['topo']
            lat_rho[i], lon_rho[i] = lower_left_y, lower_left_x

            grid_layer.changeAttributeValue(feature.id(), field_index_x, lower_left_x)
            grid_layer.changeAttributeValue(feature.id(), field_index_y, lower_left_y)
            grid_layer.changeAttributeValue(feature.id(), field_index_topo, topo[i])

        grid_layer.commitChanges()

        # Generate the grid and reshape the topography array
        h = np.reshape(topo, (numLines[0], numColumns[0]))

        return h

    def create_grid_file(self, L, M, grdname, title, directory):
        """
        This function creates a CROCO grid file with dimensions and variables.

        Parameters:
        L: int
            The size in the XI-direction.
        M: int
            The size in the ETA-direction.
        grdname: str
            The name of the grid file.
        title: str
            The title of the grid.
        directory: str
            The directory to save the grid file.

        Returns:
        grdname_full_path: str
            The full path of the grid file.
        """

        Lp = L + 1
        Mp = M + 1

        # Cr√©ation du chemin complet pour le fichier
        grdname_full_path = os.path.join(directory, grdname)
        nw = nc.Dataset(grdname_full_path, 'w', format='NETCDF4')

        # Create dimensions
        nw.createDimension('xi_u', L)
        nw.createDimension('eta_u', Mp)
        nw.createDimension('xi_v', Lp)
        nw.createDimension('eta_v', M)
        nw.createDimension('xi_rho', Lp)
        nw.createDimension('eta_rho', Mp)
        nw.createDimension('xi_psi', L)
        nw.createDimension('eta_psi', M)
        nw.createDimension('one', 1)
        nw.createDimension('two', 2)
        nw.createDimension('four', 4)
        nw.createDimension('bath', 1)

        # Create variables and attributes
        def create_ncvar(name, dimensions, long_name, units, dtype=np.double):
            var = nw.createVariable(name, dtype, dimensions)
            var.long_name = long_name
            var.units = units
            return var

        xl = create_ncvar('xl', 'one', 'domain length in the XI-direction', 'meter')
        el = create_ncvar('el', 'one', 'domain length in the ETA-direction', 'meter')
        depthmin = create_ncvar('depthmin', 'one', 'Shallow bathymetry clipping depth', 'meter')
        depthmax = create_ncvar('depthmax', 'one', 'Deep bathymetry clipping depth', 'meter')

        spherical = nw.createVariable('spherical', 'c', 'one')
        spherical.long_name = 'Grid type logical switch'
        spherical.option_T = 'spherical'

        angle = create_ncvar('angle', ('eta_rho', 'xi_rho'), 'angle between xi axis and east', 'radian')
        h = create_ncvar('h', ('eta_rho', 'xi_rho'), 'Final bathymetry at RHO-points', 'meter')
        hraw = create_ncvar('hraw', ('bath', 'eta_rho', 'xi_rho'), 'Working bathymetry at RHO-points', 'meter')
        alpha = create_ncvar('alpha', ('eta_rho', 'xi_rho'), 'Weights between coarse and fine grids at RHO-points', '')
        f = create_ncvar('f', ('eta_rho', 'xi_rho'), 'Coriolis parameter at RHO-points', 'second-1')
        pm = create_ncvar('pm', ('eta_rho', 'xi_rho'), 'curvilinear coordinate metric in XI', 'meter-1')
        pn = create_ncvar('pn', ('eta_rho', 'xi_rho'), 'curvilinear coordinate metric in ETA', 'meter-1')
        dndx = create_ncvar('dndx', ('eta_rho', 'xi_rho'), 'xi derivative of inverse metric factor pn', 'meter')
        dmde = create_ncvar('dmde', ('eta_rho', 'xi_rho'), 'eta derivative of inverse metric factor pm', 'meter')

        nw.createVariable('x_rho', 'f8', ('eta_rho', 'xi_rho'))
        nw['x_rho'].long_name = 'x location of RHO-points'
        nw['x_rho'].units = 'meter'

        nw.createVariable('x_u', 'f8', ('eta_u', 'xi_u'))
        nw['x_u'].long_name = 'x location of U-points'
        nw['x_u'].units = 'meter'

        nw.createVariable('x_v', 'f8', ('eta_v', 'xi_v'))
        nw['x_v'].long_name = 'x location of V-points'
        nw['x_v'].units = 'meter'

        nw.createVariable('x_psi', 'f8', ('eta_psi', 'xi_psi'))
        nw['x_psi'].long_name = 'x location of PSI-points'
        nw['x_psi'].units = 'meter'

        # y location variables
        nw.createVariable('y_rho', 'f8', ('eta_rho', 'xi_rho'))
        nw['y_rho'].long_name = 'y location of RHO-points'
        nw['y_rho'].units = 'meter'

        nw.createVariable('y_u', 'f8', ('eta_u', 'xi_u'))
        nw['y_u'].long_name = 'y location of U-points'
        nw['y_u'].units = 'meter'

        nw.createVariable('y_v', 'f8', ('eta_v', 'xi_v'))
        nw['y_v'].long_name = 'y location of V-points'
        nw['y_v'].units = 'meter'

        nw.createVariable('y_psi', 'f8', ('eta_psi', 'xi_psi'))
        nw['y_psi'].long_name = 'y location of PSI-points'
        nw['y_psi'].units = 'meter'

        # longitude variables
        nw.createVariable('lon_rho', 'f8', ('eta_rho', 'xi_rho'))
        nw['lon_rho'].long_name = 'longitude of RHO-points'
        nw['lon_rho'].units = 'degree_east'

        nw.createVariable('lon_u', 'f8', ('eta_u', 'xi_u'))
        nw['lon_u'].long_name = 'longitude of U-points'
        nw['lon_u'].units = 'degree_east'

        nw.createVariable('lon_v', 'f8', ('eta_v', 'xi_v'))
        nw['lon_v'].long_name = 'longitude of V-points'
        nw['lon_v'].units = 'degree_east'

        nw.createVariable('lon_psi', 'f8', ('eta_psi', 'xi_psi'))
        nw['lon_psi'].long_name = 'longitude of PSI-points'
        nw['lon_psi'].units = 'degree_east'

        # latitude variables
        nw.createVariable('lat_rho', 'f8', ('eta_rho', 'xi_rho'))
        nw['lat_rho'].long_name = 'latitude of RHO-points'
        nw['lat_rho'].units = 'degree_north'

        nw.createVariable('lat_u', 'f8', ('eta_u', 'xi_u'))
        nw['lat_u'].long_name = 'latitude of U-points'
        nw['lat_u'].units = 'degree_north'

        nw.createVariable('lat_v', 'f8', ('eta_v', 'xi_v'))
        nw['lat_v'].long_name = 'latitude of V-points'
        nw['lat_v'].units = 'degree_north'

        nw.createVariable('lat_psi', 'f8', ('eta_psi', 'xi_psi'))
        nw['lat_psi'].long_name = 'latitude of PSI-points'
        nw['lat_psi'].units = 'degree_north'

        nw.createVariable('mask_rho', 'f8', ('eta_rho', 'xi_rho'))
        nw['mask_rho'].long_name = 'mask on RHO-points'
        nw['mask_rho'].option_0 = 'land'
        nw['mask_rho'].option_1 = 'water'

        nw.createVariable('mask_u', 'f8', ('eta_u', 'xi_u'))
        nw['mask_u'].long_name = 'mask on U-points'
        nw['mask_u'].option_0 = 'land'
        nw['mask_u'].option_1 = 'water'

        nw.createVariable('mask_v', 'f8', ('eta_v', 'xi_v'))
        nw['mask_v'].long_name = 'mask on V-points'
        nw['mask_v'].option_0 = 'land'
        nw['mask_v'].option_1 = 'water'

        nw.createVariable('mask_psi', 'f8', ('eta_psi', 'xi_psi'))
        nw['mask_psi'].long_name = 'mask on PSI-points'
        nw['mask_psi'].option_0 = 'land'
        nw['mask_psi'].option_1 = 'water'

        # Create global attributes
        nw.title = title
        date = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        nw.date = date
        nw.type = 'CROCO grid file'

        nw.close()
        return grdname_full_path

    def get_angle_file(self, latu, lonu, spheroid="wgs84"):
        """Calculate the angle between geodetic and spherical coordinates.

        Args:
            latu (np.array): 2D array of latitudes.
            lonu (np.array): 2D array of longitudes.
            spheroid (str, optional): The name of the reference ellipsoid to use.
                Default is "wgs84".

        Returns:
            angle (np.array): 2D array of calculated angles.

        """

        # Constants for different spheroids
        SPHEROIDS = {
            'sph': (6371000.0, 6371000.0),
            'cla': (6378206.4, 6356583.8),
            'iau': (6378160, 6356774.516),
            'wgs': (6378137, 6378137 * (1 - 0.081819191 ** 2) ** 0.5)
        }

        # Get constants for the given spheroid
        A, B = SPHEROIDS.get(spheroid[:3])
        if not A or not B:
            raise ValueError("Unknown spheroid specified!")
        E = np.sqrt(A * A - B * B) / A

        # Convert degrees to radians
        latu = np.radians(latu)
        lonu = np.radians(lonu)

        # Replace zero values to prevent division by zero
        latu[latu == 0] = np.finfo(float).eps

        # Get size of the input arrays
        M, L = latu.shape

        # Split the arrays into two parts
        PHI1, XLAM1 = latu[:, :-1], lonu[:, :-1]
        PHI2, XLAM2 = latu[:, 1:], lonu[:, 1:]

        # Add small values to identical coordinates to prevent division by zero
        PHI2[PHI1 == PHI2] += 1e-14
        XLAM2[XLAM1 == XLAM2] += 1e-14

        # Calculate intermediate variables
        xnu1 = A / np.sqrt(1.0 - (E * np.sin(PHI1)) ** 2)
        xnu2 = A / np.sqrt(1.0 - (E * np.sin(PHI2)) ** 2)
        TPSI2 = (1 - E * E) * np.tan(PHI2) + E * E * xnu1 * np.sin(PHI1) / (xnu2 * np.cos(PHI2))
        DLAM = XLAM2 - XLAM1
        CTA12 = (np.cos(PHI1) * TPSI2 - np.sin(PHI1) * np.cos(DLAM)) / np.sin(DLAM)

        # Calculate azimuth and correct its range
        azim = np.arctan(1 / CTA12)
        DLAM2 = (np.abs(DLAM) < np.pi) * DLAM + (DLAM >= np.pi) * (-2 * np.pi + DLAM) + (DLAM <= -np.pi) * (
                    2 * np.pi + DLAM)
        azim += (azim < -np.pi) * 2 * np.pi - (azim >= np.pi) * 2 * np.pi
        azim += np.pi * np.sign(-azim) * (np.sign(azim) != np.sign(DLAM2))

        # Calculate the final angles
        angle = np.zeros((M, L + 1))
        angle[:, 1:L] = (np.pi / 2) - azim
        angle[:, 0] = angle[:, 1]
        angle[:, -1] = angle[:, -2]

        return angle

    def get_rho(self, dl):
        """
        This function calculates the horizontal (x) and vertical (y) distances of rho grid points.

        Parameters:
            dl (float): The grid resolution.

        Returns:
            dx_rho (np.array): The horizontal distances of rho grid points.
            dy_rho (np.array): The vertical distances of rho grid points.
        """

        # Access the 'grid' layer from the current QGIS project instance
        grid_layer = QgsProject.instance().mapLayersByName('grid')[0]

        # Initialize numpy arrays for x and y coordinates with the size of the grid_layer
        features_count = grid_layer.featureCount()
        x_rho, y_rho = np.zeros(features_count), np.zeros(features_count)

        # Iterate over the features (grid points) in the grid layer
        for i, feature in enumerate(grid_layer.getFeatures()):
            # Get the bounding box of the feature (grid point)
            bbox = feature.geometry().boundingBox()

            # Extract the lower left x and y coordinates of the bounding box
            lower_left_x = bbox.xMinimum()
            lower_left_y = bbox.yMinimum()

            # Store the lower left coordinates in the corresponding numpy arrays
            x_rho[i] = lower_left_x
            y_rho[i] = lower_left_y

        # Calculate the distances from the first point
        dx_rho = x_rho - x_rho[0]
        dy_rho = y_rho - y_rho[0]

        # Calculate the number of points along each axis
        num_x_points = int((x_rho.max() - x_rho.min()) / dl) + 1
        num_y_points = int((y_rho.max() - y_rho.min()) / dl) + 1

        # Reshape the arrays to match the grid dimensions
        dx_rho = dx_rho.reshape((num_y_points, num_x_points))
        dy_rho = dy_rho.reshape((num_y_points, num_x_points))

        return dx_rho, dy_rho

    def rho2uvp(self, rfield):
        """
        This function converts the rho coordinates to the corresponding u, v and p.

        Parameters:
            rfield (np.array): The rho-coordinates to be converted.

        Returns:
            ufield (np.array): The corresponding u-coordinates.
            vfield (np.array): The corresponding v-coordinates.
            pfield (np.array): The corresponding p-coordinates.
        """

        # Get the shape of the rho field
        Mp, Lp = rfield.shape

        # Calculate the size of the u, v, and p grids
        M = Mp - 1
        L = Lp - 1

        # Convert the rho field to the v field
        vfield = 0.5 * (rfield[0:M, :] + rfield[1:Mp, :])

        # Convert the rho field to the u field
        ufield = 0.5 * (rfield[:, 0:L] + rfield[:, 1:Lp])

        # Convert the u field to the p field
        pfield = 0.5 * (ufield[0:M, :] + ufield[1:Mp, :])

        return ufield, vfield, pfield

    def uvp_mask_file(self, rfield):
        """
        This function computes the u, v, and p fields from the rho mask by taking the
        product of adjacent elements in the horizontal and vertical directions.

        Parameters:
            rfield (np.array): The input r-field array.

        Returns:
            ufield (np.array): The computed u-field array.
            vfield (np.array): The computed v-field array.
            pfield (np.array): The computed p-field array.
        """

        # Determine the shape of rfield
        Mp, Lp = rfield.shape

        # Compute the u-field by multiplying horizontally adjacent elements in rfield
        ufield = np.zeros((Mp, Lp - 1))
        ufield[:, :] = rfield[:, :-1] * rfield[:, 1:]

        # Compute the v-field by multiplying vertically adjacent elements in rfield
        vfield = np.zeros((Mp - 1, Lp))
        vfield[:, :] = rfield[:-1, :] * rfield[1:, :]

        # Compute the p-field by multiplying vertically and horizontally adjacent elements in rfield
        pfield = np.zeros((Mp - 1, Lp - 1))
        pfield[:, :] = rfield[:-1, :-1] * rfield[:-1, 1:] * rfield[1:, :-1] * rfield[1:, 1:]

        return ufield, vfield, pfield