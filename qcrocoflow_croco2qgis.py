# -*- coding: utf-8 -*-
"""
/***************************************************************************
 qcrocoflowDockWidget
                                 A QGIS plugin
 Plugin to manage CROCO intial and result files
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Emmanuel Poizot
        email                : emmanuel.poizot@lecnam.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import netCDF4 as nc
import difflib
import numpy as np
from datetime import datetime

from qgis.PyQt import QtGui, QtWidgets, uic, Qt
#from qgis.PyQt.QtWidgets import QDialog
from qgis.PyQt.QtCore import pyqtSignal

from PyQt5.QtWidgets import QDialog, QMessageBox, QFileDialog, QGridLayout, QComboBox

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'qcrocoflow_croco2qgis_dialog.ui'), resource_suffix='') # Change 13/05/2022
class qcrocoflowCROCO2QGIS(QDialog, FORM_CLASS):
    def __init__(self, currentDir=None, parent=None):
    # Constructor of qcrocoflowCROCO2QGIS
        super(qcrocoflowCROCO2QGIS, self).__init__(parent)
        # Final Setup
        self.setupUi(self)
        # Variables iitialisations
        self.innetCDFFileName = None
        self.currentDirectory = currentDir
        self.importProgressBar.setValue(0)

        self.innetCDFFileNameButton.clicked.connect(self.SelectNetCDFInFile)
        self.innetCDFStartDateDate.dateTimeChanged.connect(self.StartDateTimeChanged)
        self.innetCDFEndDateDate.dateTimeChanged.connect(self.EndDateTimeChanged)

    def GetVariablesWithDim(self, _dataset, _dim) -> list:
    # Return a list of variables width 3 dimensions """
        retList = list()
        for v in _dataset.variables:
            if _dataset[v].ndim == _dim:
                retList.append(v)
        return retList

    def IsVariablesWithTime(self, _var, _dimtimename) -> list:
    # Return True or False if _var has _dimtimename in its dimensions """
        return _dimtimename in _var.dimensions

    def IsTimeDimension(self, _dataset, _ratio=0.6) -> tuple:
    # Search for time dimmension in the netCDF file """
        dims = [d for d in _dataset.dimensions]
        maxMatch = 0.0
        bestdName = None
        dSize = 0
        for id, dname in enumerate(dims):
            match = difflib.SequenceMatcher(None, dname, 'time')
            ratio = match.ratio()
            if ratio > maxMatch and ratio > _ratio:
                maxMatch = ratio
                dSize = _dataset.dimensions[dname].size
                bestdName = dname
        return (maxMatch > 0, bestdName, dSize)

    def StartDateTimeChanged(self, _date) -> None:
        if _date > self.innetCDFEndDateDate.dateTime():
            return
        else:
            self.innetCDFStartDateDate.setDateTime(_date)
        return

    def EndDateTimeChanged(self, _date) -> None:
        if _date < self.innetCDFStartDateDate.dateTime():
            return
        else:
            self.innetCDFEndDateDate.setDateTime(_date)
        return

    def DeleteLayout(self, _layout):
        if _layout is not None:
            while _layout.count():
                item = _layout.takeAt(0)
                widget = item.widget()
                if widget is not None:
                    widget.deleteLater()
                else:
                    self.DeleteLayout(item.layout())

    def UpdateVariablesComboBox(self, _ldicts) -> None:
    # Create combobox and fill them according variable lists"""
        # Delete evnetualy previous comboboxes
        self.DeleteLayout(self.variablesGroupBox.layout())
        gbox = QGridLayout()
        gbox.setSpacing(10)
        cbs = list()
        for d in _ldicts:
            if len(d["vars"]) == 0:
                continue
            cbs.append(QComboBox(self))
            cbs[-1].addItem("(var{}D)".format(d["dim"]))
            cbs[-1].addItems(d["vars"])
            gbox.addWidget(cbs[-1])
        self.variablesGroupBox.setLayout(gbox)
        return

    def UpdateStartEndDate(self, _min, _max) -> None:
    # Update calendar widget according time """
        self.innetCDFStartDateDate.setDateTime(_min)
        self.innetCDFStartDateDate.setDateRange(_min, _max)
        self.innetCDFEndDateDate.setDateTime(_max)
        self.innetCDFEndDateDate.setDateRange(_min, _max)
        return

    def GetInformationFromNetCDFFile(self, _file) -> tuple:
    # Update calendar widget according time found in variables"""
        try:
            dataset = nc.Dataset(_file, 'r')
        except:
            QMessageBox.warning(self, "Error", f"Can not open/access file {self.innetCDFFileName}")
            return
        # look for a time variable
        present, tName, nbrTimeSteps = self.IsTimeDimension(dataset)
        if present:
            minTime = np.nanmin(dataset[tName][:])
            maxTime = np.nanmax(dataset[tName][:])
            minDate = datetime.fromtimestamp(minTime)
            maxDate = datetime.fromtimestamp(maxTime)
            # QMessageBox.information(self, "info", f"Found time from {minDate.isoformat()} to {maxDate.isoformat()}")
            self.innetCDFStartDateDate.setDateTime(minDate)
            self.innetCDFStartDateDate.setDateRange(minDate, maxDate)
            self.innetCDFEndDateDate.setDateTime(maxDate)
            self.innetCDFEndDateDate.setDateRange(minDate, maxDate)
        else:
            QMessageBox.information(self, "info", f"Time dimension not found in {self.innetCDFFileName}")
            minDate = datetime.fromtimestamp(0)
            maxDate = datetime.fromtimestamp(0)
        # Normaly 2D variables have no time dimension
        dVar2D = {"dim":2, "vars":self.GetVariablesWithDim(dataset, 2)}
        # 3D variables may or not have time dimension
        dVar3D = {"dim":3, "vars":self.GetVariablesWithDim(dataset, 3)}
        # Normaly all 4D variables have a time dimension
        dVar4D = {"dim":4, "vars":self.GetVariablesWithDim(dataset, 4)}
        return ([minDate, maxDate], [dVar2D, dVar3D, dVar4D])

    def SelectNetCDFInFile(self) -> None:
        fileName = QFileDialog.getOpenFileName(self, "Open CROCO result netCDF file", \
                                               self.currentDirectory, "netCDF (*.nc *.NC)")
        if not fileName:
            return
        if self.innetCDFFileName == "":
            self.innetCDFFileNameLineEdit.setText("")
            return
        if isinstance(fileName, tuple):
            self.innetCDFFileName = fileName[0]
        self.innetCDFFileNameLineEdit.setText(os.path.basename(self.innetCDFFileName))

        lDate, ldVars = self.GetInformationFromNetCDFFile(self.innetCDFFileName)
        self.UpdateStartEndDate(lDate[0], lDate[1])
        self.UpdateVariablesComboBox(ldVars)

        return